# commodity_tracker/.env.example
# IMPORTANT: Rename this file to .env in your project root and fill in your actual values.
# DO NOT commit your .env file to version control if it contains sensitive keys.

# Django Settings
SECRET_KEY='your-super-secret-django-key-change-me'
DEBUG=True
ALLOWED_HOSTS='127.0.0.1,localhost' # Add other hosts for production

# Database (PostgreSQL example)
DATABASE_URL='postgres://your_db_user:your_db_password@your_db_host:your_db_port/your_db_name'

# Redis (for Celery and Caching)
REDIS_URL='redis://localhost:6379/0' # For Celery broker and cache backend
CELERY_BROKER_URL='redis://localhost:6379/0'
CELERY_RESULT_BACKEND='redis://localhost:6379/0'

# API Keys (from your api_keys.yaml and others needed)
ENTSOE_API_KEY="178d5b47-b29a-4c22-b1a7-32cf48883304"
ALPHA_VANTAGE_API_KEY="C1F822FUSGNYD3JP"
OPENWEATHER_API_KEY="46bd3e44b5cd3f99adcc426d9876e297"
API_NINJAS_KEY="0ACr6CRL0Y3dx7vElUiA7w==TRwKRELxiZ4WK15V"
FIN_MODELING_PREP_KEY="jgJm5cpZCjS87i6WgTM732T47qSl56nu"
COMMODITYPRICEAPI_KEY="003c89af-958d-47d8-90f4-b18b8408ea36"

# !!! IMPORTANT: Add your actual FRED API Key here. It's used by FREDClient. !!!
# You can get one from https://fred.stlouisfed.org/docs/api/api_key.html
FRED_API_KEY="AIzaSyAHnoZtio_7suOZ-XvWzCU6obIvrWL_PCk"

# Email (for error reporting in production, example using SendGrid)
# EMAIL_BACKEND = 'django.core.mail.backends.smtp.EmailBackend'
# EMAIL_HOST = 'smtp.sendgrid.net'
# EMAIL_PORT = 587
# EMAIL_USE_TLS = True
# EMAIL_HOST_USER = 'apikey' # This is literal string 'apikey' for SendGrid
# EMAIL_HOST_PASSWORD = 'YOUR_SENDGRID_API_KEY'
# DEFAULT_FROM_EMAIL = 'noreply@yourdomain.com'
# SERVER_EMAIL = 'errors@yourdomain.com' # For Django error emails


# commodity_tracker/commodity_tracker/settings/base.py
"""
Django settings for commodity_tracker project.

Generated by 'django-admin startproject' using Django 5.0.1.

For more information on this file, see
https://docs.djangoproject.com/en/5.0/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/5.0/ref/settings/
"""

import os
from pathlib import Path
from decouple import config, Csv
import dj_database_url # For parsing DATABASE_URL

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent.parent # Root of the Django project
APPS_DIR = BASE_DIR / "apps"


# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/5.0/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = config('SECRET_KEY')

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = config('DEBUG', default=False, cast=bool)

ALLOWED_HOSTS = config('ALLOWED_HOSTS', default='127.0.0.1,localhost', cast=Csv())


# Application definition

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',

    # Third-party apps
    'rest_framework',
    'corsheaders',
    'django_extensions', # Useful management commands
    'django_celery_beat', # For scheduled tasks

    # Local apps
    'apps.core.apps.CoreConfig', # Use AppConfig for better app management
    'apps.market.apps.MarketConfig',
]

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'corsheaders.middleware.CorsMiddleware', # CORS
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

ROOT_URLCONF = 'commodity_tracker.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [BASE_DIR / 'templates'], # Global templates directory
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'commodity_tracker.wsgi.application'


# Database
# https://docs.djangoproject.com/en/5.0/ref/settings/#databases
DATABASES = {
    'default': dj_database_url.config(
        default=config('DATABASE_URL', default=f'sqlite:///{BASE_DIR / "db.sqlite3"}'),
        conn_max_age=600 # Optional: connection pooling
    )
}


# Password validation
# https://docs.djangoproject.com/en/5.0/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]


# Internationalization
# https://docs.djangoproject.com/en/5.0/topics/i18n/

LANGUAGE_CODE = 'en-us'

TIME_ZONE = 'UTC' # Recommended to use UTC

USE_I18N = True

USE_TZ = True # Enable timezone support


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/5.0/howto/static-files/

STATIC_URL = '/static/'
STATIC_ROOT = BASE_DIR / 'staticfiles' # For collectstatic in production
STATICFILES_DIRS = [
    BASE_DIR / 'static', # Project-level static files
]

# Media files (User-uploaded files)
MEDIA_URL = '/media/'
MEDIA_ROOT = BASE_DIR / 'mediafiles'


# Default primary key field type
# https://docs.djangoproject.com/en/5.0/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'


# API Keys (loaded from .env)
ENTSOE_API_KEY = config('ENTSOE_API_KEY', default=None)
ALPHA_VANTAGE_API_KEY = config('ALPHA_VANTAGE_API_KEY', default=None)
OPENWEATHER_API_KEY = config('OPENWEATHER_API_KEY', default=None)
API_NINJAS_KEY = config('API_NINJAS_KEY', default=None)
FIN_MODELING_PREP_KEY = config('FIN_MODELING_PREP_KEY', default=None)
COMMODITYPRICEAPI_KEY = config('COMMODITYPRICEAPI_KEY', default=None)
FRED_API_KEY = config('FRED_API_KEY', default=None) # Crucial for FREDClient


# Celery Configuration
# Ensure Redis is running and accessible via REDIS_URL
CELERY_BROKER_URL = config('CELERY_BROKER_URL', default=config('REDIS_URL', default='redis://localhost:6379/0'))
CELERY_RESULT_BACKEND = config('CELERY_RESULT_BACKEND', default=config('REDIS_URL', default='redis://localhost:6379/0'))
CELERY_ACCEPT_CONTENT = ['json']
CELERY_TASK_SERIALIZER = 'json'
CELERY_RESULT_SERIALIZER = 'json'
CELERY_TIMEZONE = TIME_ZONE # Use Django's timezone
CELERY_TASK_TRACK_STARTED = True
CELERY_TASK_TIME_LIMIT = 30 * 60 # 30 minutes time limit for tasks
CELERY_BEAT_SCHEDULER = 'django_celery_beat.schedulers:DatabaseScheduler'


# Caching
# https://docs.djangoproject.com/en/5.0/topics/cache/
CACHES = {
    "default": {
        "BACKEND": "django_redis.cache.RedisCache",
        "LOCATION": config('REDIS_URL', default='redis://localhost:6379/1'), # Use a different Redis DB or prefix for cache
        "OPTIONS": {
            "CLIENT_CLASS": "django_redis.client.DefaultClient",
        }
    }
}

# Django REST Framework
# https://www.django-rest-framework.org/api-guide/settings/
REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': [
        # 'rest_framework.authentication.SessionAuthentication', # If using browsable API with login
        # 'rest_framework.authentication.TokenAuthentication', # If using token auth
    ],
    'DEFAULT_PERMISSION_CLASSES': [
        'rest_framework.permissions.AllowAny', # Adjust as needed for security
    ],
    'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination',
    'PAGE_SIZE': 10
}

# CORS Configuration
# https://pypi.org/project/django-cors-headers/
CORS_ALLOW_ALL_ORIGINS = DEBUG # For development, allow all. Restrict in production.
# CORS_ALLOWED_ORIGINS = [
#     "http://localhost:3000", # Example frontend
#     "http://127.0.0.1:3000",
# ]
# CORS_ALLOW_CREDENTIALS = True # If you need to send cookies/auth headers

# Logging Configuration
LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'formatters': {
        'verbose': {
            'format': '{levelname} {asctime} {module} {process:d} {thread:d} {message}',
            'style': '{',
        },
        'simple': {
            'format': '{levelname} {asctime} {module} {message}', # Added asctime and module
            'style': '{',
        },
    },
    'handlers': {
        'console': {
            'level': 'DEBUG' if DEBUG else 'INFO',
            'class': 'logging.StreamHandler',
            'formatter': 'simple'
        },
        # Add file handler for production if needed
        # 'file': {
        #     'level': 'WARNING',
        #     'class': 'logging.FileHandler',
        #     'filename': BASE_DIR / 'logs/django.log', # Ensure logs directory exists
        #     'formatter': 'verbose',
        # },
    },
    'root': {
        'handlers': ['console'], # Add 'file' for production if configured
        'level': 'INFO', # Root logger level
    },
    'loggers': {
        'django': {
            'handlers': ['console'], # Add 'file' for production
            'level': 'INFO', # Django's own logs
            'propagate': False,
        },
        'django.request': { # For request/response logging, can be noisy
            'handlers': ['console'],
            'level': 'WARNING', # Set to INFO or DEBUG for more detail
            'propagate': False,
        },
        'celery': { # Celery specific logger
            'handlers': ['console'],
            'level': 'INFO',
            'propagate': True,
        },
        'apps': { # Your apps' logger (e.g., logging.getLogger('apps.market.services'))
            'handlers': ['console'],
            'level': 'DEBUG' if DEBUG else 'INFO', # More verbose for your apps in DEBUG
            'propagate': True, # Allow propagation to root logger if needed
        }
        # You can define specific loggers for your apps, e.g.:
        # 'apps.market': {
        #     'handlers': ['console'],
        #     'level': 'DEBUG',
        #     'propagate': True,
        # },
    }
}

# commodity_tracker/commodity_tracker/settings/development.py
# This file would typically override settings from base.py for development.
# For simplicity in this example, most settings are controlled by .env and DEBUG flag in base.py.
# You can create this file and commodity_tracker/settings/production.py
# and use an environment variable (e.g., DJANGO_SETTINGS_MODULE) to switch between them.
# Example:
# from .base import *
# DEBUG = True
# ALLOWED_HOSTS = ['localhost', '127.0.0.1', '*'] # More permissive for dev
# EMAIL_BACKEND = 'django.core.mail.backends.console.EmailBackend'
# # Add Django Debug Toolbar settings if used
# # INSTALLED_APPS += ['debug_toolbar']
# # MIDDLEWARE += ['debug_toolbar.middleware.DebugToolbarMiddleware']
# # INTERNAL_IPS = ['127.0.0.1']


# commodity_tracker/commodity_tracker/settings/production.py
# Example:
# from .base import *
# DEBUG = False
# ALLOWED_HOSTS = ['your_production_domain.com']
# # Add other production-specific settings:
# # SECURE_SSL_REDIRECT = True
# # SESSION_COOKIE_SECURE = True
# # CSRF_COOKIE_SECURE = True
# # etc.


# commodity_tracker/commodity_tracker/__init__.py
# This will make sure the app is always imported when
# Django starts so that shared_task will use this app.
from .celery_config import app as celery_app # Renamed celery.py to celery_config.py

__all__ = ('celery_app',)


# commodity_tracker/commodity_tracker/celery_config.py 
# Renamed from celery.py to avoid potential name collision if you have a 'celery' app
import os
from celery import Celery
from django.conf import settings

# Set the default Django settings module for the 'celery' program.
# Ensure this points to your actual settings file or logic to determine it.
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'commodity_tracker.settings.base')

app = Celery('commodity_tracker')

# Using a string here means the worker doesn't have to serialize
# the configuration object to child processes.
# - namespace='CELERY' means all celery-related configuration keys
#   should have a `CELERY_` prefix.
app.config_from_object('django.conf:settings', namespace='CELERY')

# Load task modules from all registered Django app configs.
app.autodiscover_tasks(lambda: settings.INSTALLED_APPS)


@app.task(bind=True, ignore_result=True)
def debug_task(self):
    """A simple debug task for Celery."""
    print(f'Request: {self.request!r}')


# commodity_tracker/commodity_tracker/urls.py
"""
URL configuration for commodity_tracker project.
"""
from django.contrib import admin
from django.urls import path, include
from django.conf import settings
from django.conf.urls.static import static

urlpatterns = [
    path('admin/', admin.site.urls),
    path('api/market/', include('apps.market.urls')), # Include market app API URLs
    path('', include('apps.market.web_urls')), # Include market app Web URLs at root
    # path('api-auth/', include('rest_framework.urls', namespace='rest_framework')), # For browsable API login
]

# Serve static and media files during development
if settings.DEBUG:
    urlpatterns += static(settings.STATIC_URL, document_root=settings.STATIC_ROOT)
    urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)

    # Optionally add Django Debug Toolbar URLs
    # if "debug_toolbar" in settings.INSTALLED_APPS:
    #     import debug_toolbar
    #     urlpatterns = [path("__debug__/", include(debug_toolbar.urls))] + urlpatterns


# commodity_tracker/apps/core/__init__.py
# This file makes 'core' a Python package.

# commodity_tracker/apps/core/apps.py
from django.apps import AppConfig

class CoreConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'apps.core'
    verbose_name = "Core Application Utilities"


# commodity_tracker/apps/core/exceptions.py
"""
Custom exceptions for the commodity tracker application.
"""

class CommodityTrackerException(Exception):
    """Base exception for commodity tracker application."""
    pass

class DataFetchError(CommodityTrackerException):
    """Raised when data fetching from an external API fails."""
    pass

class DataProcessingError(CommodityTrackerException):
    """Raised when processing fetched data fails."""
    pass

class APIKeyMissingError(CommodityTrackerException):
    """Raised when a required API key is missing from settings."""
    pass

class RateLimitExceededError(CommodityTrackerException):
    """Raised when an API rate limit is believed to have been exceeded."""
    pass

class ConfigurationError(CommodityTrackerException):
    """Raised for application configuration issues."""
    pass


# commodity_tracker/apps/core/mixins.py
"""
Reusable mixins for the application.
"""
from django.http import JsonResponse
from django.utils.decorators import method_decorator
from django.views.decorators.cache import cache_page
# from django.core.cache import cache # Not directly used in these mixins

class CacheResponseMixin:
    """
    Mixin to add caching functionality to class-based views.
    Caches the response of the dispatch method.
    """
    cache_timeout = 300  # 5 minutes default, can be overridden in subclass

    @method_decorator(cache_page(cache_timeout))
    def dispatch(self, *args, **kwargs):
        return super().dispatch(*args, **kwargs)


class JSONResponseMixin:
    """Mixin to provide standardized JSON response functionality for views."""

    def json_response(self, data, status=200, safe=False, **kwargs):
        """Return a JSON response."""
        return JsonResponse(data, status=status, safe=safe, **kwargs)

    def success_response(self, data, message="Success", status=200, **kwargs):
        """Return a success JSON response with a standard structure."""
        response_data = {
            'status': 'success',
            'message': message,
            'data': data
        }
        return self.json_response(response_data, status=status, **kwargs)

    def error_response(self, message, error_code=None, status=400, **kwargs):
        """Return an error JSON response with a standard structure."""
        response_data = {'status': 'error', 'message': message}
        if error_code:
            response_data['error_code'] = error_code
        return self.json_response(response_data, status=status, **kwargs)


class TimestampMixin:
    """Mixin to add timestamp utility functionality (not directly for models)."""

    def get_current_timestamp(self):
        """Get current timezone-aware timestamp."""
        from django.utils import timezone
        return timezone.now()


# commodity_tracker/apps/core/utils.py
"""
Utility functions for the application.
"""
import logging
from decimal import Decimal, InvalidOperation
from datetime import datetime, timedelta # Ensure timedelta is imported
from django.utils import timezone

logger = logging.getLogger(__name__) # Define logger at module level


class PriceConverter:
    """Utility class for price conversions and formatting."""

    @staticmethod
    def to_decimal(value: any, default: Decimal = None) -> Decimal | None:
        """
        Convert a value to Decimal safely.
        Handles None, empty strings, and conversion errors.
        """
        if value is None or str(value).strip() == '':
            return default
        try:
            return Decimal(str(value))
        except (InvalidOperation, ValueError, TypeError):
            logger.warning(f"Could not convert value '{value}' (type: {type(value)}) to Decimal.")
            return default

    @staticmethod
    def format_price(price: Decimal | None, currency: str = 'USD', decimal_places: int = 2) -> str:
        """Format price with currency symbol and specified decimal places."""
        if price is None:
            return 'N/A'
        format_string = "{:,.%df}" % decimal_places
        return f"{currency} {format_string.format(price)}"


class DateTimeHelper:
    """Utility class for datetime operations."""

    @staticmethod
    def parse_date_string(date_str: str, format_str: str = '%Y-%m-%d') -> datetime | None:
        """
        Parse a date string to a timezone-aware datetime object (UTC).
        Returns None if parsing fails.
        """
        if not date_str:
            return None
        try:
            dt_naive = datetime.strptime(date_str, format_str)
            return timezone.make_aware(dt_naive, timezone.utc) # Assume UTC if naive
        except ValueError as e:
            logger.error(f"Error parsing date string '{date_str}' with format '{format_str}': {e}")
            return None

    @staticmethod
    def get_days_ago(days: int) -> datetime:
        """Get a timezone-aware datetime object for a number of days ago from now."""
        return timezone.now() - timedelta(days=days)

    @staticmethod
    def datetime_to_string(dt: datetime, format_str: str = '%Y-%m-%d %H:%M:%S') -> str | None:
        """Convert a datetime object to a string."""
        if not dt:
            return None
        return dt.strftime(format_str)


# commodity_tracker/apps/market/__init__.py
default_app_config = 'apps.market.apps.MarketConfig'


# commodity_tracker/apps/market/admin.py
from django.contrib import admin
from .models.commodity import DataSource, CommodityCategory, Commodity
from .models.market_data import PriceData, MarketUpdate

@admin.register(DataSource)
class DataSourceAdmin(admin.ModelAdmin):
    list_display = ('name', 'base_url', 'api_key_required', 'rate_limit_per_minute', 'is_active', 'created_at', 'updated_at')
    list_filter = ('api_key_required', 'is_active', 'created_at')
    search_fields = ('name', 'base_url')
    actions = ['activate_selected', 'deactivate_selected']
    readonly_fields = ('created_at', 'updated_at')

    @admin.action(description="Activate selected data sources")
    def activate_selected(self, request, queryset):
        queryset.update(is_active=True)

    @admin.action(description="Deactivate selected data sources")
    def deactivate_selected(self, request, queryset):
        queryset.update(is_active=False)


@admin.register(CommodityCategory)
class CommodityCategoryAdmin(admin.ModelAdmin):
    list_display = ('name', 'get_active_commodities_count', 'created_at', 'updated_at')
    search_fields = ('name', 'description')
    readonly_fields = ('created_at', 'updated_at')

    @admin.display(description='Active Commodities')
    def get_active_commodities_count(self, obj):
        return obj.get_commodities_count() # Uses the model method


@admin.register(Commodity)
class CommodityAdmin(admin.ModelAdmin):
    list_display = ('name', 'symbol', 'category', 'exchange', 'data_source', 'is_active', 'created_at')
    list_filter = ('is_active', 'category', 'data_source', 'exchange', 'currency')
    search_fields = ('name', 'symbol', 'external_id', 'exchange')
    autocomplete_fields = ['category', 'data_source']
    actions = ['activate_selected', 'deactivate_selected']
    readonly_fields = ('id', 'created_at', 'updated_at')
    fieldsets = (
        (None, {
            'fields': ('id', 'name', 'symbol', 'is_active')
        }),
        ('Categorization & Source', {
            'fields': ('category', 'data_source', 'external_id')
        }),
        ('Market Details', {
            'fields': ('exchange', 'unit', 'currency')
        }),
        ('Timestamps', {
            'fields': ('created_at', 'updated_at'),
            'classes': ('collapse',) # Collapsible section
        }),
    )

    @admin.action(description="Activate selected commodities")
    def activate_selected(self, request, queryset):
        for item in queryset:
            item.activate() # Uses the model method

    @admin.action(description="Deactivate selected commodities")
    def deactivate_selected(self, request, queryset):
        for item in queryset:
            item.deactivate() # Uses the model method


@admin.register(PriceData)
class PriceDataAdmin(admin.ModelAdmin):
    list_display = ('commodity_link', 'timestamp', 'open_price', 'high_price', 'low_price', 'close_price', 'volume_display')
    list_filter = ('timestamp', 'commodity__category', 'commodity__data_source') # Filter by commodity's category/source
    search_fields = ('commodity__name', 'commodity__symbol')
    date_hierarchy = 'timestamp' # Adds a date drilldown navigation
    readonly_fields = ('created_at', 'updated_at')
    list_select_related = ('commodity',) # Optimize query for commodity
    ordering = ('-timestamp',)

    @admin.display(description='Commodity', ordering='commodity__symbol')
    def commodity_link(self, obj):
        from django.urls import reverse
        from django.utils.html import format_html
        link = reverse("admin:market_commodity_change", args=[obj.commodity.id])
        return format_html('<a href="{}">{}</a>', link, obj.commodity.symbol)

    @admin.display(description='Volume', ordering='volume')
    def volume_display(self, obj):
        return f"{obj.volume:,}" if obj.volume is not None else "N/A"


@admin.register(MarketUpdate)
class MarketUpdateAdmin(admin.ModelAdmin):
    list_display = ('id', 'data_source_name', 'commodity_symbol', 'status', 'records_fetched', 'records_created', 'started_at_display', 'duration_display')
    list_filter = ('status', 'data_source__name', 'commodity__category', 'started_at')
    search_fields = ('commodity__name', 'commodity__symbol', 'error_message', 'id')
    readonly_fields = ('id', 'data_source', 'commodity', 'started_at', 'completed_at', 'created_at', 'updated_at', 'error_message',
                       'records_fetched', 'records_created', 'records_updated')
    list_select_related = ('data_source', 'commodity')
    ordering = ('-started_at',)

    @admin.display(description='Data Source', ordering='data_source__name')
    def data_source_name(self, obj):
        return obj.data_source.name if obj.data_source else "N/A"

    @admin.display(description='Commodity', ordering='commodity__symbol')
    def commodity_symbol(self, obj):
        return obj.commodity.symbol if obj.commodity else "N/A (Source Level)"

    @admin.display(description='Started At', ordering='started_at')
    def started_at_display(self, obj):
        return obj.started_at.strftime('%Y-%m-%d %H:%M:%S') if obj.started_at else "N/A"

    @admin.display(description='Duration')
    def duration_display(self, obj):
        duration = obj.duration
        if duration:
            total_seconds = int(duration.total_seconds())
            hours, remainder = divmod(total_seconds, 3600)
            minutes, seconds = divmod(remainder, 60)
            if hours > 0:
                return f"{hours}h {minutes}m {seconds}s"
            elif minutes > 0:
                return f"{minutes}m {seconds}s"
            return f"{seconds}s"
        return "N/A"


# commodity_tracker/apps/market/apps.py
from django.apps import AppConfig

class MarketConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'apps.market'
    verbose_name = "Market Data Management"

    def ready(self):
        # Import signals here if you have any for the market app
        # Example: from . import signals
        pass


# commodity_tracker/apps/market/models/__init__.py
from .base import TimeStampedModel, UUIDModel, ActiveModel
from .commodity import DataSource, CommodityCategory, Commodity
from .market_data import PriceData, MarketUpdate

__all__ = [
    'TimeStampedModel', 'UUIDModel', 'ActiveModel',
    'DataSource', 'CommodityCategory', 'Commodity',
    'PriceData', 'MarketUpdate',
]


# commodity_tracker/apps/market/models/base.py
"""
Base abstract models for the market application.
"""
import uuid
from django.db import models
# from django.utils import timezone # Not directly used in these base models

class TimeStampedModel(models.Model):
    """Abstract base model with auto-managed created_at and updated_at fields."""
    created_at = models.DateTimeField(auto_now_add=True, editable=False, help_text="Timestamp when the record was created.")
    updated_at = models.DateTimeField(auto_now=True, editable=False, help_text="Timestamp when the record was last updated.")

    class Meta:
        abstract = True
        ordering = ['-created_at'] # Default ordering for inheriting models


class UUIDModel(models.Model):
    """Abstract base model using a UUID as the primary key."""
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False, help_text="Unique identifier (UUID).")

    class Meta:
        abstract = True


class ActiveModel(models.Model):
    """Abstract base model providing an 'is_active' flag and methods to manage it."""
    is_active = models.BooleanField(default=True, help_text="Designates whether this record is considered active.")

    class Meta:
        abstract = True

    def activate(self):
        """Activates the instance if it's not already active."""
        if not self.is_active:
            self.is_active = True
            self.save(update_fields=['is_active'])

    def deactivate(self):
        """Deactivates the instance if it's currently active."""
        if self.is_active:
            self.is_active = False
            self.save(update_fields=['is_active'])


# commodity_tracker/apps/market/models/commodity.py
"""
Commodity-related models: DataSource, CommodityCategory, and Commodity.
"""
from django.db import models
from django.utils import timezone
from datetime import timedelta
from .base import TimeStampedModel, UUIDModel, ActiveModel
from ..managers.commodity_managers import CommodityManager, ActiveCommodityManager
from django.core.exceptions import ValidationError


class DataSource(TimeStampedModel, ActiveModel):
    """Model representing data sources for commodity information (e.g., APIs)."""
    name = models.CharField(max_length=100, unique=True, help_text="Name of the data source (e.g., Alpha Vantage, FRED).")
    base_url = models.URLField(max_length=255, help_text="Base URL for the API, if applicable.")
    api_key_required = models.BooleanField(default=True, help_text="Does this data source require an API key?")
    rate_limit_per_minute = models.PositiveIntegerField(
        default=5,
        null=True, blank=True, # Can be null if not applicable or unknown
        help_text="Informational: Approximate rate limit per minute. Actual enforcement is in service layer."
    )

    class Meta(TimeStampedModel.Meta): # Inherit ordering from TimeStampedModel
        db_table = 'market_data_source'
        verbose_name = "Data Source"
        verbose_name_plural = "Data Sources"

    def __str__(self):
        return self.name

    def clean(self):
        super().clean()
        if self.base_url and not self.base_url.startswith(('http://', 'https://')):
            raise ValidationError({'base_url': "URL must start with 'http://' or 'https://'."})


class CommodityCategory(TimeStampedModel):
    """Model representing categories for commodities (e.g., Energy, Metals, Grains)."""
    name = models.CharField(max_length=100, unique=True, help_text="Name of the commodity category.")
    description = models.TextField(blank=True, help_text="Optional description for the category.")

    class Meta(TimeStampedModel.Meta):
        verbose_name = "Commodity Category"
        verbose_name_plural = "Commodity Categories"
        db_table = 'market_commodity_category'

    def __str__(self):
        return self.name

    def get_commodities_count(self) -> int:
        """Returns the count of active commodities in this category."""
        return self.commodities.filter(is_active=True).count()


class Commodity(UUIDModel, TimeStampedModel, ActiveModel):
    """Model representing a tradable commodity."""
    name = models.CharField(max_length=200, help_text="Full name of the commodity (e.g., Crude Oil, Gold, Corn).")
    symbol = models.CharField(max_length=50, unique=True, help_text="Unique trading symbol or ticker for the commodity.") # Increased length
    category = models.ForeignKey(
        CommodityCategory,
        on_delete=models.SET_NULL,
        null=True,
        blank=True, # Category can be optional
        related_name='commodities',
        help_text="Category this commodity belongs to."
    )
    exchange = models.CharField(max_length=100, blank=True, help_text="Exchange where this commodity is primarily traded (e.g., NYMEX, COMEX).")
    unit = models.CharField(max_length=50, blank=True, help_text="Unit of measurement for the commodity's price (e.g., Barrel, Ounce, Bushel).")
    currency = models.CharField(max_length=10, default='USD', help_text="Currency in which the price is denoted (e.g., USD, EUR).") # Increased length
    data_source = models.ForeignKey(
        DataSource,
        on_delete=models.PROTECT, # Prevent deleting a data source if commodities are linked to it.
        related_name='commodities',
        help_text="Primary data source for this commodity's price information."
    )
    external_id = models.CharField(
        max_length=100,
        help_text="ID used by the external data source (e.g., specific symbol for Alpha Vantage, series ID for FRED)."
    )
    meta_data = models.JSONField(default=dict, blank=True, help_text="Optional JSON field for storing additional metadata about the commodity.")


    # Custom managers
    objects = CommodityManager()  # Default manager
    active = ActiveCommodityManager()  # Manager for active_only commodities

    class Meta(TimeStampedModel.Meta, UUIDModel.Meta): # Inherit ordering and ensure UUIDModel Meta is also considered
        indexes = [
            models.Index(fields=['symbol']),
            models.Index(fields=['category']),
            models.Index(fields=['is_active']),
            models.Index(fields=['data_source', 'external_id']),
            models.Index(fields=['name']), # Index on name for searching
        ]
        unique_together = [['data_source', 'external_id']] # External ID should be unique per data source
        db_table = 'market_commodity'
        verbose_name = "Commodity"
        verbose_name_plural = "Commodities"

    def __str__(self):
        return f"{self.name} ({self.symbol})"

    def get_latest_price(self) -> 'PriceData | None':
        """Get the most recent PriceData point for this commodity."""
        return self.prices.order_by('-timestamp').first()

    def get_price_history(self, days: int = 30) -> models.QuerySet['PriceData']:
        """Get price history for the specified number of days, ordered chronologically."""
        start_date = timezone.now() - timedelta(days=days)
        return self.prices.filter(timestamp__gte=start_date).order_by('timestamp')

    def has_recent_data(self, hours: int = 24) -> bool:
        """Check if the commodity has price data within the recent specified hours."""
        cutoff = timezone.now() - timedelta(hours=hours)
        return self.prices.filter(timestamp__gte=cutoff).exists()

    def clean(self):
        super().clean()
        # Example validation: Ensure symbol is uppercase if that's a convention
        if self.symbol:
            self.symbol = self.symbol.upper()


# commodity_tracker/apps/market/models/market_data.py
"""
Market data models: PriceData (for individual price points) and MarketUpdate (for logging data fetch operations).
"""
from django.db import models
from django.utils import timezone
from .base import TimeStampedModel
from .commodity import Commodity, DataSource # DataSource for MarketUpdate FK


class PriceData(TimeStampedModel):
    """Model representing a single price data point for a commodity at a specific time."""
    commodity = models.ForeignKey(
        Commodity,
        on_delete=models.CASCADE, # If commodity is deleted, its price data is also deleted.
        related_name='prices',
        help_text="The commodity this price data belongs to."
    )
    timestamp = models.DateTimeField(help_text="The specific date and time for this price data point (usually UTC).")
    open_price = models.DecimalField(max_digits=15, decimal_places=6, null=True, blank=True, help_text="Opening price.") # Increased precision
    high_price = models.DecimalField(max_digits=15, decimal_places=6, null=True, blank=True, help_text="Highest price during the period.")
    low_price = models.DecimalField(max_digits=15, decimal_places=6, null=True, blank=True, help_text="Lowest price during the period.")
    close_price = models.DecimalField(max_digits=15, decimal_places=6, help_text="Closing price.") # Assuming close price is mandatory
    volume = models.BigIntegerField(null=True, blank=True, help_text="Trading volume during the period.")
    source_data = models.JSONField(default=dict, blank=True, help_text="Raw data snippet from the source for this price point, for auditing or reprocessing.")


    class Meta(TimeStampedModel.Meta):
        unique_together = ['commodity', 'timestamp'] # Each commodity can only have one price point per timestamp
        indexes = [
            # unique_together implies an index, but explicit definition can be clearer or allow more options
            models.Index(fields=['commodity', 'timestamp'], name='market_pricedata_com_time_idx'),
            models.Index(fields=['timestamp'], name='market_pricedata_time_idx'), # For querying by time across commodities
        ]
        # Default ordering: latest prices first, then by commodity symbol
        ordering = ['-timestamp', 'commodity__symbol']
        db_table = 'market_price_data'
        verbose_name = "Price Data"
        verbose_name_plural = "Price Data"

    def __str__(self):
        commodity_symbol = self.commodity.symbol if self.commodity else 'N/A'
        return (f"{commodity_symbol} @ {self.timestamp.strftime('%Y-%m-%d %H:%M')} - "
                f"Close: {self.close_price} {self.commodity.currency if self.commodity else ''}")

    @property
    def price_change(self) -> models.Decimal | None:
        """Calculates the absolute price change from open to close. Returns Decimal or None."""
        if self.open_price is not None and self.close_price is not None:
            return self.close_price - self.open_price
        return None

    @property
    def price_change_percentage(self) -> models.Decimal | None:
        """Calculates the percentage price change from open. Returns Decimal or None."""
        change = self.price_change
        if change is not None and self.open_price is not None and self.open_price != 0:
            return (change / self.open_price) * 100
        return None


class MarketUpdate(TimeStampedModel, models.Model): # Explicitly inherit from models.Model for UUID pk if needed, or use UUIDModel
    """Model representing a log of market data update operations (e.g., fetching data from an API)."""
    id = models.UUIDField(primary_key=True, default=models.UUIDField().default, editable=False) # Explicit UUID PK

    STATUS_CHOICES = [
        ('PENDING', 'Pending'),
        ('RUNNING', 'Running'),
        ('SUCCESS', 'Success'),
        ('FAILED', 'Failed'),
        ('PARTIAL', 'Partial Success'), # If some records updated but errors occurred
    ]

    data_source = models.ForeignKey(
        DataSource,
        on_delete=models.CASCADE, # Or PROTECT if logs are critical even if source is deleted
        related_name='update_logs', # Changed related_name for clarity
        help_text="The data source used for this update operation."
    )
    commodity = models.ForeignKey(
        Commodity,
        on_delete=models.CASCADE, # Or PROTECT
        null=True,
        blank=True, # If the update is for the entire data source, not a specific commodity
        related_name='update_logs', # Changed related_name
        help_text="Specific commodity updated, if applicable."
    )
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='PENDING', help_text="Current status of the update operation.")
    task_id = models.CharField(max_length=255, null=True, blank=True, help_text="Celery task ID, if applicable.")
    records_fetched = models.PositiveIntegerField(default=0, help_text="Number of raw records/data points fetched from the API.")
    records_created = models.PositiveIntegerField(default=0, help_text="Number of new PriceData records created in the database.")
    records_updated = models.PositiveIntegerField(default=0, help_text="Number of existing PriceData records updated (if applicable).")
    error_message = models.TextField(blank=True, null=True, help_text="Error message if the update operation failed or had issues.")
    started_at = models.DateTimeField(null=True, blank=True, help_text="Timestamp when the update operation started.")
    completed_at = models.DateTimeField(null=True, blank=True, help_text="Timestamp when the update operation completed.")

    class Meta(TimeStampedModel.Meta):
        # Default ordering: latest started updates first
        ordering = ['-started_at', '-created_at']
        db_table = 'market_update_log'
        verbose_name = "Market Update Log"
        verbose_name_plural = "Market Update Logs"

    def __str__(self):
        commodity_info = f" - {self.commodity.symbol}" if self.commodity else " (Source Level)"
        source_name = self.data_source.name if self.data_source else "N/A"
        start_time = (self.started_at or self.created_at).strftime('%Y-%m-%d %H:%M')
        return f"Update Log {self.id_short()}: {source_name}{commodity_info} - {self.status} @ {start_time}"

    def id_short(self):
        return str(self.id).split('-')[0] # Short version of UUID for display

    def mark_as_running(self, task_id=None):
        """Sets the status to RUNNING and records the start time."""
        self.status = 'RUNNING'
        self.started_at = timezone.now()
        if task_id:
            self.task_id = task_id
        self.save(update_fields=['status', 'started_at', 'task_id'] if task_id else ['status', 'started_at'])

    def mark_as_completed(self, status='SUCCESS', records_fetched=None, records_created=None, records_updated=None, error_message=None):
        """Marks the update as completed with the given status and details."""
        self.status = status
        if records_fetched is not None: self.records_fetched = records_fetched
        if records_created is not None: self.records_created = records_created
        if records_updated is not None: self.records_updated = records_updated
        self.error_message = error_message
        self.completed_at = timezone.now()
        
        fields_to_update = ['status', 'completed_at', 'error_message']
        if records_fetched is not None: fields_to_update.append('records_fetched')
        if records_created is not None: fields_to_update.append('records_created')
        if records_updated is not None: fields_to_update.append('records_updated')
        
        self.save(update_fields=fields_to_update)

    @property
    def duration(self) -> timedelta | None:
        """Calculates the duration of the update operation. Returns timedelta or None."""
        if self.started_at and self.completed_at:
            return self.completed_at - self.started_at
        elif self.started_at and self.status == 'RUNNING': # If still running
            return timezone.now() - self.started_at
        return None


# commodity_tracker/apps/market/managers/__init__.py
from .commodity_managers import CommodityQuerySet, CommodityManager, ActiveCommodityManager

__all__ = [
    'CommodityQuerySet', 'CommodityManager', 'ActiveCommodityManager',
]


# commodity_tracker/apps/market/managers/commodity_managers.py
"""
Custom managers and QuerySets for Commodity models.
"""
from django.db import models
from django.db.models import Count, Q # Added Q for more complex queries if needed
from django.utils import timezone
from datetime import timedelta


class CommodityQuerySet(models.QuerySet):
    """Custom QuerySet for the Commodity model."""

    def active(self):
        """Filters for active commodities (is_active=True)."""
        return self.filter(is_active=True)

    def inactive(self):
        """Filters for inactive commodities (is_active=False)."""
        return self.filter(is_active=False)

    def by_category_name(self, category_name: str):
        """Filters commodities by category name (case-insensitive contains)."""
        return self.filter(category__name__icontains=category_name)

    def by_category_id(self, category_id):
        """Filters commodities by category ID."""
        return self.filter(category_id=category_id)

    def with_recent_price_data(self, hours: int = 24):
        """
        Filters commodities that have associated PriceData entries within the last specified hours.
        Uses distinct to avoid duplicates if a commodity has multiple recent prices.
        """
        cutoff_time = timezone.now() - timedelta(hours=hours)
        return self.filter(prices__timestamp__gte=cutoff_time).distinct()

    def without_recent_price_data(self, hours: int = 24):
        """
        Filters commodities that DO NOT have associated PriceData entries within the last specified hours.
        """
        cutoff_time = timezone.now() - timedelta(hours=hours)
        return self.exclude(prices__timestamp__gte cutoff_time).distinct()


    def by_exchange(self, exchange_name: str):
        """Filters commodities by exchange name (case-insensitive contains)."""
        return self.filter(exchange__icontains=exchange_name)

    def by_data_source(self, data_source_name: str):
        """Filters commodities by data source name."""
        return self.filter(data_source__name__iexact=data_source_name)

    def needs_update(self, hours: int = 24):
        """
        Identifies commodities that might need a price update.
        This could be commodities with no recent data or those not updated recently.
        (This is a basic example; more sophisticated logic might be needed).
        """
        # Commodities that don't have price data in the last `hours`
        return self.without_recent_price_data(hours)


class CommodityManager(models.Manager):
    """Custom manager for the Commodity model."""

    def get_queryset(self):
        return CommodityQuerySet(self.model, using=self._db)

    def active(self):
        """Returns a QuerySet of active commodities."""
        return self.get_queryset().active()

    def inactive(self):
        """Returns a QuerySet of inactive commodities."""
        return self.get_queryset().inactive()

    def by_category_name(self, category_name: str):
        """Returns commodities filtered by category name."""
        return self.get_queryset().by_category_name(category_name)

    def with_recent_price_data(self, hours: int = 24):
        """Returns commodities with recent price data."""
        return self.get_queryset().with_recent_price_data(hours)

    def get_popular_commodities(self, limit: int = 10):
        """
        Gets popular commodities.
        Popularity can be defined in various ways, e.g., by the number of recent price updates
        or by the number of times they've been part of a MarketUpdate log.
        This example uses the count of associated PriceData entries.
        """
        return (
            self.active()
            .annotate(price_data_count=Count('prices'))
            .order_by('-price_data_count', 'name')[:limit]
        )

    def get_commodities_for_update(self, hours_since_last_data: int = 24):
        """Gets commodities that likely need a price data update."""
        return self.get_queryset().needs_update(hours=hours_since_last_data)


class ActiveCommodityManager(models.Manager):
    """A manager that returns only active (is_active=True) commodities by default."""

    def get_queryset(self):
        # Calls the custom CommodityQuerySet and filters for active items.
        return CommodityQuerySet(self.model, using=self._db).active()

    # You can add other methods here that should also operate only on active commodities.
    # For example:
    # def by_category_name(self, category_name: str):
    #     return self.get_queryset().by_category_name(category_name)


# commodity_tracker/apps/market/serializers/__init__.py
from .commodity_serializers import (
    DataSourceSerializer,
    CommodityCategorySerializer,
    PriceDataSerializer,
    CommoditySerializer,
    CommodityDetailSerializer,
    MarketUpdateLogSerializer,
)

__all__ = [
    'DataSourceSerializer',
    'CommodityCategorySerializer',
    'PriceDataSerializer',
    'CommoditySerializer',
    'CommodityDetailSerializer',
    'MarketUpdateLogSerializer',
]


# commodity_tracker/apps/market/serializers/commodity_serializers.py
from rest_framework import serializers
from apps.market.models import Commodity, CommodityCategory, PriceData, DataSource, MarketUpdate

class DataSourceSerializer(serializers.ModelSerializer):
    class Meta:
        model = DataSource
        fields = ['id', 'name', 'base_url', 'api_key_required', 'rate_limit_per_minute', 'is_active', 'created_at', 'updated_at']
        read_only_fields = ('id', 'created_at', 'updated_at')

class CommodityCategorySerializer(serializers.ModelSerializer):
    active_commodities_count = serializers.IntegerField(source='get_commodities_count', read_only=True)
    class Meta:
        model = CommodityCategory
        fields = ['id', 'name', 'description', 'active_commodities_count', 'created_at', 'updated_at']
        read_only_fields = ('id', 'active_commodities_count', 'created_at', 'updated_at')

class PriceDataSerializer(serializers.ModelSerializer):
    price_change = serializers.DecimalField(max_digits=15, decimal_places=6, read_only=True, allow_null=True)
    price_change_percentage = serializers.DecimalField(max_digits=15, decimal_places=6, read_only=True, allow_null=True)
    commodity_symbol = serializers.CharField(source='commodity.symbol', read_only=True)

    class Meta:
        model = PriceData
        fields = [
            'id', 'commodity', 'commodity_symbol', 'timestamp', 'open_price', 'high_price', 'low_price',
            'close_price', 'volume', 'price_change', 'price_change_percentage',
            'created_at', 'updated_at', 'source_data'
        ]
        read_only_fields = ('id', 'commodity_symbol', 'created_at', 'updated_at')
        # 'commodity' field will be writeable for creating PriceData if needed, but often handled by nested writes or service layer.

class CommodityBasicSerializer(serializers.ModelSerializer):
    """A more basic serializer for embedding or simple lists."""
    category_name = serializers.CharField(source='category.name', read_only=True, allow_null=True)
    data_source_name = serializers.CharField(source='data_source.name', read_only=True)
    class Meta:
        model = Commodity
        fields = ['id', 'name', 'symbol', 'category_name', 'data_source_name', 'currency', 'is_active']


class CommoditySerializer(serializers.ModelSerializer):
    category_name = serializers.CharField(source='category.name', read_only=True, allow_null=True)
    data_source_name = serializers.CharField(source='data_source.name', read_only=True)
    latest_price = PriceDataSerializer(source='get_latest_price', read_only=True, allow_null=True)
    # category = CommodityCategorySerializer(read_only=True) # Can be too verbose for list, use in DetailSerializer
    # data_source = DataSourceSerializer(read_only=True)   # Same as above

    class Meta:
        model = Commodity
        fields = [
            'id', 'name', 'symbol', 'category', 'category_name', 'exchange',
            'unit', 'currency', 'data_source', 'data_source_name', 'external_id',
            'is_active', 'created_at', 'updated_at', 'latest_price', 'meta_data'
        ]
        read_only_fields = ('id', 'created_at', 'updated_at', 'latest_price', 'category_name', 'data_source_name')
        # Make category and data_source writable by their IDs
        extra_kwargs = {
            'category': {'write_only': True, 'required': False, 'allow_null': True},
            'data_source': {'write_only': True},
        }

class CommodityDetailSerializer(CommoditySerializer):
    category = CommodityCategorySerializer(read_only=True, allow_null=True) # Show full category object on detail
    data_source = DataSourceSerializer(read_only=True)   # Show full data_source object on detail
    # price_history = PriceDataSerializer(many=True, read_only=True, source='get_price_history') # Example: can be heavy

    class Meta(CommoditySerializer.Meta):
        # Inherit fields and add/override as needed
        fields = CommoditySerializer.Meta.fields + ['category', 'data_source'] # Ensure these are included if overridden
        # Remove write_only extra_kwargs for category and data_source as they are now read_only objects
        extra_kwargs = {}


class MarketUpdateLogSerializer(serializers.ModelSerializer):
    data_source_name = serializers.CharField(source='data_source.name', read_only=True)
    commodity_symbol = serializers.CharField(source='commodity.symbol', read_only=True, allow_null=True)
    duration = serializers.DurationField(read_only=True, allow_null=True)

    class Meta:
        model = MarketUpdate
        fields = [
            'id', 'data_source', 'data_source_name', 'commodity', 'commodity_symbol',
            'status', 'task_id', 'records_fetched', 'records_created', 'records_updated',
            'error_message', 'started_at', 'completed_at', 'duration',
            'created_at', 'updated_at'
        ]
        read_only_fields = ('id', 'data_source_name', 'commodity_symbol', 'duration', 'created_at', 'updated_at')
        extra_kwargs = { # For creating/updating if needed, though often handled by services
            'data_source': {'write_only': True},
            'commodity': {'write_only': True, 'required': False, 'allow_null': True},
        }


# commodity_tracker/apps/market/services/__init__.py
from .base import BaseDataService, BaseAPIClient
from .data_fetcher import AlphaVantageClient, FREDClient, CommodityDataFetcherOrchestrator
from .price_processor import PriceDataProcessor, MarketUpdateOrchestrationService

__all__ = [
    'BaseDataService', 'BaseAPIClient',
    'AlphaVantageClient', 'FREDClient', 'CommodityDataFetcherOrchestrator', # Changed CommodityDataFetcher
    'PriceDataProcessor', 'MarketUpdateOrchestrationService', # Changed MarketUpdateService
]


# commodity_tracker/apps/market/services/base.py
"""
Base service classes for data fetching and API interaction.
"""
import logging
import requests # Import at the top
from abc import ABC, abstractmethod
from typing import Dict, Any, Optional
from apps.core.exceptions import DataFetchError, APIKeyMissingError, ConfigurationError


class BaseDataService(ABC):
    """Abstract base class for services that fetch and process data."""

    def __init__(self, api_key: Optional[str] = None):
        self.api_key = api_key # Specific API key for this service instance, if passed directly
        self.logger = logging.getLogger(f"apps.{self.__class__.__module__}.{self.__class__.__name__}")

    @abstractmethod
    def fetch_data(self, *args, **kwargs) -> Optional[Dict[str, Any]]:
        """Fetches data from an external source."""
        pass

    @abstractmethod
    def process_data(self, data: Dict[str, Any], *args, **kwargs) -> int:
        """
        Processes fetched data.
        Should return a count, e.g., number of records created or processed.
        """
        pass

    def validate_api_key_is_present(self) -> None:
        """Validates that an API key is available for the service if it's required."""
        # This method is more for services that might receive an API key dynamically.
        # Clients like AlphaVantageClient usually get keys from Django settings.
        if not self.api_key:
            raise APIKeyMissingError(f"An API key is required for {self.__class__.__name__} but was not provided.")

    def handle_service_error(self, error: Exception, context: str = "", raise_as: Exception = DataFetchError) -> None:
        """Handles errors consistently within the service."""
        error_msg = f"Error in {self.__class__.__name__} during {context}: {str(error)}"
        self.logger.error(error_msg, exc_info=True) # Log with full traceback
        raise raise_as(error_msg) from error


class BaseAPIClient(ABC):
    """Abstract base class for HTTP API clients."""

    def __init__(self, base_url: str, api_key: Optional[str] = None, timeout: int = 30):
        if not base_url:
            raise ConfigurationError(f"{self.__class__.__name__} requires a base_url.")
        self.base_url = base_url.rstrip('/')
        self.api_key = api_key # API key specific to this client instance
        self.timeout = timeout
        self._session = None # Use a private attribute for the session
        self.logger = logging.getLogger(f"apps.{self.__class__.__module__}.{self.__class__.__name__}")

    @property
    def session(self) -> requests.Session:
        """Provides a requests.Session instance, creating it if it doesn't exist."""
        if self._session is None:
            self._session = requests.Session()
            # Example: Set a default User-Agent header
            self._session.headers.update({
                'User-Agent': f'CommodityTrackerApp/1.0 ({self.__class__.__name__})'
            })
        return self._session

    @abstractmethod
    def build_request_params(self, **kwargs) -> Dict[str, Any]:
        """Builds the dictionary of parameters for an API request."""
        pass

    def _make_request(self, method: str, endpoint: str, params: Optional[Dict[str, Any]] = None,
                      json_data: Optional[Dict[str, Any]] = None, headers: Optional[Dict[str, str]] = None) -> Dict[str, Any]:
        """
        Internal method to make an HTTP request to the API.
        Handles common request logic and error handling.
        """
        url = f"{self.base_url}/{endpoint.lstrip('/')}"
        request_headers = self.session.headers.copy() # Start with session headers
        if headers:
            request_headers.update(headers)

        self.logger.debug(f"Making {method.upper()} request to {url} with params: {params}, json: {json_data}")

        try:
            response = self.session.request(
                method=method.upper(),
                url=url,
                params=params, # For GET request query parameters
                json=json_data, # For POST/PUT request body (sent as JSON)
                headers=request_headers,
                timeout=self.timeout
            )
            response.raise_for_status()  # Raises HTTPError for bad responses (4XX or 5XX)

            if not response.content: # Check for empty response
                self.logger.warning(f"Empty response received from {url} (status: {response.status_code}).")
                return {} # Or raise an error, depending on expected behavior for this API

            return response.json() # Assumes JSON response
        except requests.exceptions.HTTPError as http_err:
            err_content = http_err.response.text[:500] if http_err.response else "No response content"
            self.logger.error(f"HTTP error for {url}: {http_err.response.status_code} - {err_content}", exc_info=True)
            raise DataFetchError(f"API request to {url} failed with status {http_err.response.status_code}: {err_content}") from http_err
        except requests.exceptions.ConnectionError as conn_err:
            self.logger.error(f"Connection error for {url}: {conn_err}", exc_info=True)
            raise DataFetchError(f"Could not connect to API at {url}: {conn_err}") from conn_err
        except requests.exceptions.Timeout as timeout_err:
            self.logger.error(f"Timeout error for {url}: {timeout_err}", exc_info=True)
            raise DataFetchError(f"API request to {url} timed out: {timeout_err}") from timeout_err
        except requests.exceptions.RequestException as req_err: # Catch-all for other requests issues
            self.logger.error(f"Request error for {url}: {req_err}", exc_info=True)
            raise DataFetchError(f"API request to {url} failed: {req_err}") from req_err
        except ValueError as json_err: # Handles JSONDecodeError if response is not valid JSON
            response_text_snippet = response.text[:200] if response else "No response object"
            self.logger.error(f"JSON decoding error for {url}: {json_err}. Response text: {response_text_snippet}", exc_info=True)
            raise DataFetchError(f"Failed to decode JSON response from {url}: {json_err}") from json_err

    def get(self, endpoint: str, params: Optional[Dict[str, Any]] = None, headers: Optional[Dict[str, str]] = None) -> Dict[str, Any]:
        """Performs a GET request."""
        return self._make_request("GET", endpoint, params=params, headers=headers)

    def post(self, endpoint: str, json_data: Optional[Dict[str, Any]] = None, params: Optional[Dict[str, Any]] = None, headers: Optional[Dict[str, str]] = None) -> Dict[str, Any]:
        """Performs a POST request with JSON data."""
        return self._make_request("POST", endpoint, json_data=json_data, params=params, headers=headers)


# commodity_tracker/apps/market/services/data_fetcher.py
"""
Data fetching services for different external APIs (Alpha Vantage, FRED, etc.).
These services are responsible for making HTTP requests and handling API-specific responses.
"""
from typing import Dict, Any, Optional
from django.conf import settings
from .base import BaseAPIClient # BaseDataService not directly used by clients, but by orchestrator
from apps.core.exceptions import DataFetchError, RateLimitExceededError, APIKeyMissingError, ConfigurationError
from apps.market.models import Commodity # For type hinting


class AlphaVantageClient(BaseAPIClient):
    """API client for Alpha Vantage."""

    DEFAULT_BASE_URL = "https://www.alphavantage.co"

    def __init__(self, api_key: Optional[str] = None, base_url: Optional[str] = None):
        resolved_api_key = api_key or settings.ALPHA_VANTAGE_API_KEY
        if not resolved_api_key:
            raise APIKeyMissingError("Alpha Vantage API key (ALPHA_VANTAGE_API_KEY) not found in settings or provided.")
        super().__init__(
            base_url=base_url or self.DEFAULT_BASE_URL,
            api_key=resolved_api_key
        )

    def build_request_params(self, function: str, symbol: str, **kwargs) -> Dict[str, Any]:
        """Builds request parameters common to many Alpha Vantage functions."""
        params = {
            'function': function,
            'symbol': symbol,
            'apikey': self.api_key,
        }
        # Add common optional parameters
        if 'interval' in kwargs: params['interval'] = kwargs['interval'] # e.g., '5min', 'daily'
        if 'outputsize' in kwargs: params['outputsize'] = kwargs['outputsize'] # 'compact' or 'full'
        if 'datatype' in kwargs: params['datatype'] = kwargs['datatype'] # 'json' or 'csv'
        return params

    def fetch_time_series_daily(self, symbol: str, outputsize: str = 'compact') -> Dict[str, Any]:
        """Fetches TIME_SERIES_DAILY_ADJUSTED data."""
        params = self.build_request_params(
            function='TIME_SERIES_DAILY_ADJUSTED', # Using adjusted as it's often more useful
            symbol=symbol,
            outputsize=outputsize
        )
        self.logger.info(f"Fetching Alpha Vantage TIME_SERIES_DAILY for symbol: {symbol}")
        data = self.get('query', params=params)
        return self._handle_alpha_vantage_response(data, symbol)

    # Add other methods for different Alpha Vantage functions as needed
    # Example:
    # def fetch_commodity_wti(self, interval: str = 'monthly') -> Dict[str, Any]:
    #     params = self.build_request_params(function='WTI', symbol=None, interval=interval) # Symbol might not be needed for some global commodities
    #     self.logger.info(f"Fetching Alpha Vantage WTI data with interval: {interval}")
    #     data = self.get('query', params=params)
    #     return self._handle_alpha_vantage_response(data, "WTI")

    def _handle_alpha_vantage_response(self, data: Dict[str, Any], request_identifier: str) -> Dict[str, Any]:
        """Handles common Alpha Vantage API response patterns (errors, notes)."""
        if not data:
            self.logger.warning(f"Empty response from Alpha Vantage for {request_identifier}.")
            return {} # Or raise DataFetchError("Empty response")

        if 'Error Message' in data:
            error_msg = data['Error Message']
            self.logger.error(f"Alpha Vantage API error for {request_identifier}: {error_msg}")
            raise DataFetchError(f"Alpha Vantage API error: {error_msg}")

        # Alpha Vantage often includes rate limit notes or informational messages
        note = data.get('Note') or data.get('Information')
        if note:
            self.logger.warning(f"Alpha Vantage API note for {request_identifier}: {note}")
            # Basic check for rate limit message (these messages can vary)
            if "call frequency" in note.lower() or "premium endpoint" in note.lower():
                raise RateLimitExceededError(f"Alpha Vantage rate limit likely exceeded or premium endpoint hit: {note}")
        return data


class FREDClient(BaseAPIClient):
    """API client for FRED (Federal Reserve Economic Data)."""

    DEFAULT_BASE_URL = "https://api.stlouisfed.org/fred"

    def __init__(self, api_key: Optional[str] = None, base_url: Optional[str] = None):
        resolved_api_key = api_key or settings.FRED_API_KEY
        if not resolved_api_key:
            raise APIKeyMissingError("FRED API key (FRED_API_KEY) not found in settings or provided.")
        super().__init__(
            base_url=base_url or self.DEFAULT_BASE_URL,
            api_key=resolved_api_key
        )

    def build_request_params(self, series_id: str, **kwargs) -> Dict[str, Any]:
        """Builds request parameters for FRED series observations."""
        params = {
            'series_id': series_id,
            'api_key': self.api_key,
            'file_type': 'json', # Always request JSON
        }
        # Common optional parameters for /series/observations
        if 'limit' in kwargs: params['limit'] = kwargs['limit'] # Max 100000 if allowed, default 1000
        if 'sort_order' in kwargs: params['sort_order'] = kwargs['sort_order'] # 'asc' or 'desc'
        if 'observation_start' in kwargs: params['observation_start'] = kwargs['observation_start'] # YYYY-MM-DD
        if 'observation_end' in kwargs: params['observation_end'] = kwargs['observation_end'] # YYYY-MM-DD
        if 'units' in kwargs: params['units'] = kwargs['units'] # e.g., 'lin' (levels), 'chg' (change)
        if 'frequency' in kwargs: params['frequency'] = kwargs['frequency'] # e.g., 'd', 'w', 'm', 'q', 'a'
        return params

    def fetch_series_observations(self, series_id: str, **kwargs) -> Dict[str, Any]:
        """Fetches observations for a given FRED series ID."""
        params = self.build_request_params(series_id, **kwargs)
        self.logger.info(f"Fetching FRED series observations for series_id: {series_id}")
        data = self.get('series/observations', params=params)
        return self._handle_fred_response(data, series_id)

    def _handle_fred_response(self, data: Dict[str, Any], request_identifier: str) -> Dict[str, Any]:
        """Handles common FRED API response patterns."""
        if not data:
            self.logger.warning(f"Empty response from FRED for {request_identifier}.")
            return {}

        # FRED API errors are usually in the response body with an error_code or message
        error_code = data.get('error_code')
        error_message = data.get('error_message')
        if error_code or error_message:
            full_error_msg = error_message or f"FRED API error code: {error_code}"
            self.logger.error(f"FRED API error for {request_identifier}: {full_error_msg}")
            # Check for common rate limit error codes if known (e.g., 429 is a common HTTP status for rate limits)
            # FRED's specific error codes for rate limits would need to be identified from their docs.
            if error_code == 429 or "rate limit" in (error_message or "").lower():
                 raise RateLimitExceededError(f"FRED rate limit likely exceeded: {full_error_msg}")
            raise DataFetchError(full_error_msg)
        return data


class CommodityDataFetcherOrchestrator(BaseAPIClient): # Changed from BaseDataService to BaseAPIClient as it orchestrates API clients
    """
    Orchestrates data fetching from various configured sources based on Commodity settings.
    This class itself doesn't directly call external APIs but delegates to specific clients.
    """
    # No direct API key or base_url here, as it uses other clients.
    # The BaseAPIClient inheritance is more for consistent logging and structure.

    def __init__(self):
        # Initialize clients. Could be done lazily or via dependency injection.
        # For simplicity, initializing here.
        # The __init__ of BaseAPIClient requires base_url, so provide a dummy one or refactor BaseAPIClient
        super().__init__(base_url="http://internal-orchestrator") # Dummy base_url
        self._alpha_vantage_client: Optional[AlphaVantageClient] = None
        self._fred_client: Optional[FREDClient] = None
        self.logger = logging.getLogger(f"apps.{self.__class__.__module__}.{self.__class__.__name__}")


    @property
    def alpha_vantage(self) -> AlphaVantageClient:
        """Lazy loads the AlphaVantageClient."""
        if self._alpha_vantage_client is None:
            try:
                self._alpha_vantage_client = AlphaVantageClient()
            except APIKeyMissingError as e:
                self.logger.error(f"Failed to initialize AlphaVantageClient: {e}")
                raise ConfigurationError(f"Alpha Vantage client cannot be initialized: {e}") from e
        return self._alpha_vantage_client

    @property
    def fred(self) -> FREDClient:
        """Lazy loads the FREDClient."""
        if self._fred_client is None:
            try:
                self._fred_client = FREDClient()
            except APIKeyMissingError as e:
                self.logger.error(f"Failed to initialize FREDClient: {e}")
                raise ConfigurationError(f"FRED client cannot be initialized: {e}") from e
        return self._fred_client

    def fetch_data_for_commodity(self, commodity: Commodity, **kwargs) -> Optional[Dict[str, Any]]:
        """
        Fetches data for a given Commodity object based on its configured data_source.
        kwargs can be passed to the specific client's fetch method (e.g., outputsize for AlphaVantage).
        """
        if not commodity.data_source:
            self.logger.error(f"Commodity {commodity.symbol} has no data_source configured.")
            raise ConfigurationError(f"Data source not configured for commodity {commodity.symbol}.")

        source_name = commodity.data_source.name.lower()
        external_id = commodity.external_id

        self.logger.info(f"Fetching data for commodity: {commodity.symbol} (Ext. ID: {external_id}) from source: {source_name}")

        try:
            if source_name == 'alpha vantage':
                # Example: Assuming Alpha Vantage needs 'TIME_SERIES_DAILY'
                # You might need more sophisticated logic to determine the correct function
                # based on commodity type or metadata stored in the Commodity model.
                return self.alpha_vantage.fetch_time_series_daily(symbol=external_id, **kwargs)
            elif source_name == 'fred':
                return self.fred.fetch_series_observations(series_id=external_id, **kwargs)
            # Add other data sources here:
            # elif source_name == 'another_api':
            #     client = AnotherApiClient() # Initialize or get client
            #     return client.fetch_data(external_id, **kwargs)
            else:
                self.logger.warning(f"Data source '{source_name}' is not implemented or recognized for commodity {commodity.symbol}.")
                raise DataFetchError(f"Unsupported data source: {commodity.data_source.name}")
        except ConfigurationError as e: # Catch client init errors
            self.logger.error(f"Configuration error for source {source_name} while fetching for {commodity.symbol}: {e}")
            raise # Re-raise to be handled by the caller (e.g., MarketUpdateService)
        except DataFetchError as e: # Catch specific data fetch errors from clients
            self.logger.error(f"DataFetchError for {commodity.symbol} from {source_name}: {e}")
            raise # Re-raise
        except Exception as e: # Catch any other unexpected errors
            self.logger.exception(f"Unexpected error fetching data for {commodity.symbol} from {source_name}: {e}")
            raise DataFetchError(f"Unexpected error during data fetch for {commodity.symbol}: {e}") from e
    
    # This method is not from BaseAPIClient, so it's removed or refactored if this class truly inherits from BaseDataService
    # def process_data(self, data: Dict[str, Any], commodity: Commodity, *args, **kwargs) -> int:
    #     from .price_processor import PriceDataProcessor # Local import to avoid circular dependency
    #     # ... (processing logic was here, now moved to MarketUpdateService which uses PriceDataProcessor)
    #     pass

    # This class doesn't directly build request params, it delegates. So, this abstract method from BaseAPIClient is not applicable.
    def build_request_params(self, **kwargs) -> Dict[str, Any]:
        self.logger.warning("build_request_params called on CommodityDataFetcherOrchestrator, which is unexpected.")
        return {}


# commodity_tracker/apps/market/services/price_processor.py
"""
Service for processing fetched price data and saving it to the database.
Also includes a service for managing and logging market update operations.
"""
import logging
from decimal import Decimal
from typing import Dict, Any, List, Tuple, Optional # Ensure Optional is imported
from django.utils import timezone
from django.db import transaction, IntegrityError

from apps.core.utils import PriceConverter, DateTimeHelper
from apps.market.models import PriceData, Commodity, MarketUpdate # Import MarketUpdate
from apps.core.exceptions import DataProcessingError, APIKeyMissingError, RateLimitExceededError, DataFetchError, ConfigurationError
from .data_fetcher import CommodityDataFetcherOrchestrator # Import the orchestrator

logger = logging.getLogger(__name__) # Define logger at module level


class PriceDataProcessor:
    """
    Service responsible for transforming raw data from different sources
    into PriceData model instances and saving them.
    """
    def __init__(self):
        self.price_converter = PriceConverter()
        self.date_helper = DateTimeHelper()
        self.logger = logging.getLogger(f"apps.{self.__class__.__module__}.{self.__class__.__name__}")


    def _prepare_price_data_entries(
        self,
        commodity: Commodity,
        parsed_items: List[Dict[str, Any]] # Each dict should have 'timestamp' and other price fields
    ) -> List[PriceData]:
        """
        Prepares a list of PriceData model instances from parsed items, avoiding duplicates.
        `parsed_items` is a list of dictionaries, each representing a potential PriceData record.
        Each dictionary must contain a 'timestamp' (datetime object) and price fields.
        """
        price_data_to_create = []
        
        # Get timestamps of items to potentially create
        timestamps_to_check = [item['timestamp'] for item in parsed_items if 'timestamp' in item and item['timestamp'] is not None]
        if not timestamps_to_check:
            return []

        # Find existing PriceData records for these timestamps and this commodity
        existing_timestamps = set(
            PriceData.objects.filter(
                commodity=commodity,
                timestamp__in=timestamps_to_check
            ).values_list('timestamp', flat=True)
        )
        self.logger.debug(f"For {commodity.symbol}, found {len(existing_timestamps)} existing timestamps out of {len(timestamps_to_check)} to check.")

        for item_data in parsed_items:
            timestamp = item_data.get('timestamp')
            if not timestamp or not isinstance(timestamp, timezone.datetime): # Ensure it's a datetime object
                self.logger.warning(f"Skipping entry for {commodity.symbol} due to invalid or missing timestamp: {timestamp}")
                continue

            if timestamp not in existing_timestamps:
                # Ensure close_price is valid before creating object
                if item_data.get('close_price') is None:
                    self.logger.warning(f"Skipping entry for {commodity.symbol} at {timestamp} due to missing 'close_price'. Data: {item_data}")
                    continue
                
                # Pop timestamp as it's a direct field, not in **defaults
                item_data.pop('timestamp', None) 
                
                price_data_to_create.append(
                    PriceData(
                        commodity=commodity,
                        timestamp=timestamp,
                        **item_data # Pass remaining fields as kwargs
                    )
                )
            # else:
            #     self.logger.debug(f"Price data for {commodity.symbol} at {timestamp} already exists. Skipping.")
        return price_data_to_create

    @transaction.atomic
    def _bulk_create_price_data(self, commodity: Commodity, price_data_list: List[PriceData]) -> int:
        """
        Bulk creates PriceData objects using a transaction.
        Returns the number of records successfully created.
        """
        if not price_data_list:
            return 0
        try:
            # ignore_conflicts=True means if a unique constraint (commodity, timestamp) is violated,
            # the conflicting row is ignored, and the process continues.
            # This is useful if the pre-check for existing timestamps isn't perfectly in sync
            # due to concurrent operations, though less likely in typical Celery task scenarios.
            created_objects = PriceData.objects.bulk_create(price_data_list, ignore_conflicts=True)
            num_created = len(created_objects) # bulk_create with ignore_conflicts on PostgreSQL returns objects that were created
            self.logger.info(f"Bulk created {num_created} new price data records for {commodity.symbol}.")
            return num_created
        except IntegrityError as e: # Should be rare with ignore_conflicts=True and pre-check
            self.logger.error(f"Integrity error during bulk create for {commodity.symbol}: {e}", exc_info=True)
            # Fallback or re-raise. For now, log and return 0 for this batch.
            return 0
        except Exception as e:
            self.logger.error(f"Unexpected error during bulk create for {commodity.symbol}: {e}", exc_info=True)
            raise DataProcessingError(f"Bulk creation of price data failed for {commodity.symbol}") from e

    def process_alpha_vantage_data(self, commodity: Commodity, raw_data: Dict[str, Any]) -> int:
        """
        Processes Alpha Vantage price data (e.g., from TIME_SERIES_DAILY).
        Returns the number of new PriceData records created.
        """
        time_series_key = next((k for k in raw_data if "Time Series" in k or "Monthly" in k or "Weekly" in k or "Daily" in k), None)
        if not time_series_key or not isinstance(raw_data.get(time_series_key), dict):
            self.logger.warning(f"No valid time series data found in Alpha Vantage response for {commodity.symbol}. Keys: {list(raw_data.keys())}")
            return 0

        time_series = raw_data[time_series_key]
        parsed_items_for_db = []

        for date_str, price_point_data in time_series.items():
            timestamp = self.date_helper.parse_date_string(date_str)
            if not timestamp:
                self.logger.warning(f"Could not parse date string '{date_str}' for {commodity.symbol} from Alpha Vantage. Skipping.")
                continue

            # Alpha Vantage keys are like '1. open', '2. high', etc.
            # Standardize these to match PriceData model fields.
            item_data = {
                'timestamp': timestamp,
                'open_price': self.price_converter.to_decimal(price_point_data.get(next((k for k in price_point_data if 'open' in k.lower()), None))),
                'high_price': self.price_converter.to_decimal(price_point_data.get(next((k for k in price_point_data if 'high' in k.lower()), None))),
                'low_price': self.price_converter.to_decimal(price_point_data.get(next((k for k in price_point_data if 'low' in k.lower()), None))),
                'close_price': self.price_converter.to_decimal(price_point_data.get(next((k for k in price_point_data if 'close' in k.lower()), None))),
                'volume': self.price_converter.to_decimal(price_point_data.get(next((k for k in price_point_data if 'volume' in k.lower()), None))), # Volume can be decimal
                'source_data': price_point_data # Store raw snippet
            }
            # Convert volume to int if it's a Decimal and whole number, or handle as needed
            if isinstance(item_data['volume'], Decimal):
                 item_data['volume'] = int(item_data['volume']) if item_data['volume'] == item_data['volume'].to_integral_value() else None


            if item_data['close_price'] is not None:
                parsed_items_for_db.append(item_data)
            else:
                self.logger.warning(f"Missing or invalid close price for {commodity.symbol} on {date_str} from Alpha Vantage. Data: {price_point_data}")

        if not parsed_items_for_db:
            return 0

        price_data_objects = self._prepare_price_data_entries(commodity, parsed_items_for_db)
        return self._bulk_create_price_data(commodity, price_data_objects)

    def process_fred_data(self, commodity: Commodity, raw_data: Dict[str, Any]) -> int:
        """
        Processes FRED price data from the 'observations' list.
        Returns the number of new PriceData records created.
        """
        if not raw_data or 'observations' not in raw_data or not isinstance(raw_data['observations'], list):
            self.logger.warning(f"No valid 'observations' data found in FRED response for {commodity.symbol}.")
            return 0

        observations = raw_data['observations']
        parsed_items_for_db = []

        for obs in observations:
            value_str = obs.get('value')
            if value_str is None or str(value_str).strip() == '.': # FRED uses '.' for missing values
                self.logger.debug(f"Skipping FRED observation for {commodity.symbol} due to missing/invalid value on date {obs.get('date')}.")
                continue

            timestamp = self.date_helper.parse_date_string(obs.get('date'))
            if not timestamp:
                self.logger.warning(f"Could not parse date string '{obs.get('date')}' for {commodity.symbol} from FRED. Skipping.")
                continue

            close_price = self.price_converter.to_decimal(value_str)
            if close_price is None:
                self.logger.warning(f"Could not convert value '{value_str}' to Decimal for {commodity.symbol} on {obs.get('date')} from FRED. Skipping.")
                continue

            # FRED data typically only provides a single value (interpreted as close_price)
            item_data = {
                'timestamp': timestamp,
                'close_price': close_price,
                'source_data': obs # Store raw snippet
                # open, high, low, volume are typically not available directly from FRED observations for price series.
            }
            parsed_items_for_db.append(item_data)

        if not parsed_items_for_db:
            return 0

        price_data_objects = self._prepare_price_data_entries(commodity, parsed_items_for_db)
        return self._bulk_create_price_data(commodity, price_data_objects)


class MarketUpdateOrchestrationService:
    """
    Service for managing the overall market data update process, including logging.
    It uses CommodityDataFetcherOrchestrator to get data and PriceDataProcessor to save it.
    """
    def __init__(self):
        self.data_fetcher = CommodityDataFetcherOrchestrator()
        self.price_processor = PriceDataProcessor()
        self.logger = logging.getLogger(f"apps.{self.__class__.__module__}.{self.__class__.__name__}")

    def _get_processor_method_for_source(self, source_name: str):
        """Helper to get the correct PriceDataProcessor method for a given source name."""
        source_name_lower = source_name.lower()
        if source_name_lower == 'alpha vantage':
            return self.price_processor.process_alpha_vantage_data
        elif source_name_lower == 'fred':
            return self.price_processor.process_fred_data
        # Add other sources here
        # elif source_name_lower == 'another_api':
        #     return self.price_processor.process_another_api_data
        else:
            self.logger.warning(f"No specific data processing method found for source: {source_name}")
            return None


    def update_single_commodity(self, commodity: Commodity, task_id: Optional[str] = None, **fetch_kwargs) -> Tuple[bool, str, int]:
        """
        Updates price data for a single commodity.
        Creates and manages a MarketUpdate log entry.
        Returns a tuple: (success_bool, message_str, records_created_int).
        `fetch_kwargs` are passed to the data_fetcher.
        """
        self.logger.info(f"Starting price update for commodity: {commodity.symbol} (ID: {commodity.id}), Task ID: {task_id}")
        update_log = MarketUpdate.objects.create(
            data_source=commodity.data_source,
            commodity=commodity,
            status='PENDING',
            task_id=task_id
        )
        update_log.mark_as_running(task_id=task_id) # Also sets started_at

        records_created = 0
        success = False
        message = ""

        try:
            raw_data = self.data_fetcher.fetch_data_for_commodity(commodity, **fetch_kwargs)
            
            if raw_data:
                # Estimate records fetched (crude estimation based on source)
                num_fetched = self._estimate_records_in_raw_data(raw_data, commodity.data_source.name)
                update_log.records_fetched = num_fetched
                # update_log.save(update_fields=['records_fetched']) # Save immediately or with mark_as_completed

                processor_method = self._get_processor_method_for_source(commodity.data_source.name)
                if processor_method:
                    records_created = processor_method(commodity, raw_data)
                    if records_created > 0:
                        message = f"Successfully created {records_created} new price records for {commodity.symbol}."
                        update_log.mark_as_completed(status='SUCCESS', records_fetched=num_fetched, records_created=records_created)
                        success = True
                    else:
                        message = f"Data fetched for {commodity.symbol}, but no new price records were created (data might be old, malformed, or already exist)."
                        update_log.mark_as_completed(status='PARTIAL', records_fetched=num_fetched, records_created=0, error_message=message)
                        # success remains False or could be True depending on definition of "partial success"
                else:
                    message = f"No data processor available for source '{commodity.data_source.name}' for commodity {commodity.symbol}."
                    update_log.mark_as_completed(status='FAILED', records_fetched=num_fetched, error_message=message)
            else:
                message = f"No data received from {commodity.data_source.name} for {commodity.symbol}."
                update_log.mark_as_completed(status='FAILED', error_message=message)

        except (APIKeyMissingError, ConfigurationError) as config_err:
            message = f"Configuration error for {commodity.data_source.name} updating {commodity.symbol}: {config_err}"
            self.logger.error(message)
            update_log.mark_as_completed(status='FAILED', error_message=str(config_err))
        except RateLimitExceededError as rl_err:
            message = f"Rate limit exceeded for {commodity.data_source.name} updating {commodity.symbol}: {rl_err}"
            self.logger.warning(message) # Warning as it's an API constraint
            update_log.mark_as_completed(status='FAILED', error_message=str(rl_err))
        except DataFetchError as df_err:
            message = f"Data fetch error for {commodity.symbol} from {commodity.data_source.name}: {df_err}"
            self.logger.error(message)
            update_log.mark_as_completed(status='FAILED', error_message=str(df_err))
        except DataProcessingError as dp_err:
            message = f"Data processing error for {commodity.symbol}: {dp_err}"
            self.logger.error(message)
            update_log.mark_as_completed(status='FAILED', error_message=str(dp_err))
        except Exception as e:
            message = f"An unexpected error occurred updating {commodity.symbol}: {e}"
            self.logger.exception(message) # Logs full traceback
            update_log.mark_as_completed(status='FAILED', error_message=str(e))
            # For Celery, re-raising might be desired to mark task as FAILED explicitly
            # raise
        
        self.logger.info(f"Completed update for {commodity.symbol}. Success: {success}, Message: {message}, New Records: {records_created}")
        return success, message, records_created

    def _estimate_records_in_raw_data(self, raw_data: Dict[str, Any], source_name: str) -> int:
        """Helper to estimate number of primary records in raw data based on source conventions."""
        try:
            source_name_lower = source_name.lower()
            if source_name_lower == 'alpha vantage':
                # Find a key that looks like a time series
                time_series_key = next((k for k in raw_data if "Time Series" in k or "Monthly" in k or "Weekly" in k or "Daily" in k), None)
                if time_series_key and isinstance(raw_data.get(time_series_key), dict):
                    return len(raw_data[time_series_key])
            elif source_name_lower == 'fred':
                if 'observations' in raw_data and isinstance(raw_data['observations'], list):
                    return len(raw_data['observations'])
        except Exception:
            self.logger.warning(f"Could not estimate records from raw_data for source {source_name}.", exc_info=True)
        return 0 # Default if estimation fails or source unknown

    def update_all_active_commodities(self, task_id_prefix: Optional[str] = None, **fetch_kwargs) -> Dict[str, Any]:
        """
        Updates prices for all active commodities.
        Typically called by a scheduled task.
        Returns a summary dictionary of the operation.
        `fetch_kwargs` are passed to individual commodity updates.
        """
        active_commodities = Commodity.active.all().select_related('data_source', 'category')
        num_commodities = active_commodities.count()
        self.logger.info(f"Starting batch update for {num_commodities} active commodities. Task ID Prefix: {task_id_prefix}")

        summary = {
            'total_commodities_to_process': num_commodities,
            'processed_count': 0,
            'successful_updates': 0,
            'partial_success_updates': 0,
            'failed_updates': 0,
            'total_new_records_created': 0,
            'details': [] # List of dicts: {'symbol', 'status_message', 'records_created'}
        }

        for i, commodity in enumerate(active_commodities):
            # Construct a unique task_id if a prefix is given for better tracking
            current_task_id = f"{task_id_prefix}_{commodity.id}" if task_id_prefix else None
            
            success, message, records_created = self.update_single_commodity(commodity, task_id=current_task_id, **fetch_kwargs)
            
            summary['processed_count'] += 1
            summary['total_new_records_created'] += records_created
            summary['details'].append({
                'commodity_id': str(commodity.id),
                'symbol': commodity.symbol,
                'status_message': message,
                'records_created': records_created,
                'update_successful': success
            })

            if success:
                summary['successful_updates'] += 1
            elif "no new price records were created" in message and "Data fetched" in message: # Heuristic for partial success
                summary['partial_success_updates'] += 1
            else:
                summary['failed_updates'] += 1
            
            self.logger.info(f"Batch update progress: {summary['processed_count']}/{num_commodities} commodities processed.")

        self.logger.info(f"Finished batch updating all active commodities. Summary: {summary}")
        return summary


# commodity_tracker/apps/market/signals.py
# Example: (Uncomment and implement if needed)
# from django.db.models.signals import post_save
# from django.dispatch import receiver
# from .models import Commodity
# import logging

# logger = logging.getLogger(__name__)

# @receiver(post_save, sender=Commodity)
# def commodity_saved_handler(sender, instance, created, **kwargs):
#     if created:
#         logger.info(f"New commodity created: {instance.name} ({instance.symbol})")
#         # You could trigger an initial price fetch task here, for example:
#         # from .tasks import update_single_commodity_prices_task
#         # update_single_commodity_prices_task.delay(commodity_id=str(instance.id))
#     else:
#         logger.info(f"Commodity updated: {instance.name} ({instance.symbol})")


# commodity_tracker/apps/market/tasks/__init__.py
from .price_tasks import (
    update_single_commodity_prices_task,
    update_all_active_commodities_prices_task,
    cleanup_old_market_update_logs_task,
)

__all__ = [
    'update_single_commodity_prices_task',
    'update_all_active_commodities_prices_task',
    'cleanup_old_market_update_logs_task',
]


# commodity_tracker/apps/market/tasks/price_tasks.py
from celery import shared_task, group
from django.utils import timezone
import logging

from apps.market.models import Commodity
from apps.market.services.price_processor import MarketUpdateOrchestrationService # Use the orchestration service

logger = logging.getLogger(__name__) # Celery tasks often use their own logger instances

@shared_task(bind=True, name="market.update_single_commodity", max_retries=3, default_retry_delay=5 * 60) # Retry 3 times, 5 min delay
def update_single_commodity_prices_task(self, commodity_id: str, **fetch_kwargs):
    """
    Celery task to update prices for a single commodity.
    `fetch_kwargs` can include parameters like 'observation_start' for FRED.
    """
    task_id = self.request.id # Get Celery's task ID
    logger.info(f"Task {task_id}: Starting price update for commodity_id: {commodity_id} with kwargs: {fetch_kwargs}")
    try:
        commodity = Commodity.objects.select_related('data_source').get(id=commodity_id)
    except Commodity.DoesNotExist:
        logger.error(f"Task {task_id}: Commodity with id {commodity_id} not found. Task cannot proceed.")
        # No retry for this, as commodity doesn't exist.
        return f"Failed: Commodity with id {commodity_id} not found."

    service = MarketUpdateOrchestrationService()
    try:
        success, message, records_created = service.update_single_commodity(commodity, task_id=str(task_id), **fetch_kwargs)
        log_message = f"Task {task_id} for {commodity.symbol}: {message} (New records: {records_created})"
        if success:
            logger.info(log_message)
            return f"Success: {log_message}"
        else:
            logger.warning(log_message)
            # Depending on the failure type, you might want to retry.
            # For example, if it was a rate limit or temporary network issue.
            # The service layer should raise specific exceptions that can be caught here for retry logic.
            # For now, just return the message. If an exception was raised by the service, Celery handles retry based on task decorator.
            return f"Partial/Failed: {log_message}"
    except Exception as e:
        logger.exception(f"Task {task_id}: Unhandled exception for commodity {commodity.symbol if 'commodity' in locals() else commodity_id}: {e}")
        # Re-raise the exception. Celery will use this to determine retry behavior or mark as FAILED.
        # The `bind=True` and `self` allow access to `self.retry()`.
        try:
            self.retry(exc=e) # Celery will handle retry based on max_retries
        except self.MaxRetriesExceededError:
            logger.error(f"Task {task_id}: Max retries exceeded for commodity {commodity.symbol if 'commodity' in locals() else commodity_id}.")
            return f"Failed after max retries: {e}"
        # If retry is not desired for all exceptions, add more specific error handling.


@shared_task(bind=True, name="market.update_all_active_commodities")
def update_all_active_commodities_prices_task(self, **fetch_kwargs):
    """
    Celery task to update prices for ALL active commodities.
    This can either call the service method that loops, or create a group of subtasks.
    Creating a group of subtasks is often better for observability and parallelism.
    `fetch_kwargs` are passed to individual commodity update tasks/service calls.
    """
    task_id = self.request.id
    logger.info(f"Task {task_id}: Starting update for ALL active commodities with kwargs: {fetch_kwargs}")

    # Option 1: Use the service method that iterates (simpler, less Celery overhead for this task itself)
    # service = MarketUpdateOrchestrationService()
    # try:
    #     results_summary = service.update_all_active_commodities(task_id_prefix=str(task_id), **fetch_kwargs)
    #     logger.info(f"Task {task_id}: Update all active commodities task completed. Summary: {results_summary}")
    #     return f"Completed. Processed: {results_summary.get('processed_count', 0)}, Successful: {results_summary.get('successful_updates',0)}, Failed: {results_summary.get('failed_updates',0)}"
    # except Exception as e:
    #     logger.exception(f"Task {task_id}: update_all_active_commodities_prices_task failed: {e}")
    #     raise # Re-raise for Celery to handle

    # Option 2: Create a group of subtasks (better for parallelism and individual task tracking in Celery)
    active_commodity_ids = list(Commodity.active.values_list('id', flat=True))
    if not active_commodity_ids:
        logger.info(f"Task {task_id}: No active commodities found to update.")
        return "No active commodities to update."

    # Create a signature for each subtask
    # Pass fetch_kwargs to each subtask
    subtasks = [update_single_commodity_prices_task.s(str(commodity_id), **fetch_kwargs) for commodity_id in active_commodity_ids]
    
    # Create a group to run these subtasks in parallel (or sequentially if broker limits concurrency)
    task_group = group(subtasks)
    
    logger.info(f"Task {task_id}: Created a group of {len(subtasks)} subtasks to update active commodities.")
    
    # Execute the group. This is asynchronous. The result of this parent task
    # will be a GroupResult object if you need to track its completion.
    # For a fire-and-forget scheduled task, simply calling it is often enough.
    group_result = task_group.apply_async()
    
    logger.info(f"Task {task_id}: Group of update tasks dispatched with Group ID: {group_result.id}")
    return f"Dispatched {len(subtasks)} commodity update tasks. Group ID: {group_result.id}"


@shared_task(name="market.cleanup_logs")
def cleanup_old_market_update_logs_task(days_to_keep: int = 90):
    """
    Celery task to clean up old MarketUpdate log entries.
    """
    from apps.market.models import MarketUpdate # Local import for Celery task

    cutoff_date = timezone.now() - timezone.timedelta(days=days_to_keep)
    task_id = cleanup_old_market_update_logs_task.request.id # Get task ID if needed
    logger.info(f"Task {task_id}: Starting cleanup of MarketUpdate logs older than {cutoff_date} ({days_to_keep} days).")

    try:
        # Ensure that MarketUpdate has a 'created_at' field if using it for filtering.
        # The TimeStampedModel provides this.
        deleted_count, _ = MarketUpdate.objects.filter(created_at__lt=cutoff_date).delete()
        logger.info(f"Task {task_id}: Successfully deleted {deleted_count} old MarketUpdate log entries.")
        return f"Deleted {deleted_count} MarketUpdate logs older than {days_to_keep} days."
    except Exception as e:
        logger.exception(f"Task {task_id}: Error during cleanup_old_market_update_logs_task: {e}")
        raise # Re-raise for Celery to mark as FAILED


# commodity_tracker/apps/market/urls.py
# This file is for API URLs
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import api_views # Ensure api_views is imported correctly

# DRF Router for API ViewSets
# Routers provide an easy way of automatically determining the URL conf.
router = DefaultRouter()
router.register(r'commodities', api_views.CommodityViewSet, basename='commodity')
router.register(r'categories', api_views.CommodityCategoryViewSet, basename='commoditycategory')
router.register(r'datasources', api_views.DataSourceViewSet, basename='datasource')
router.register(r'price-data', api_views.PriceDataViewSet, basename='pricedata') # For listing/retrieving price data
router.register(r'update-logs', api_views.MarketUpdateLogViewSet, basename='marketupdatelog')


# The API URLs are now determined automatically by the router.
# urlpatterns = router.urls # This would be the simplest form

# Or, if you want to prefix them, e.g., with /v1/
app_name = 'market-api' # Namespace for API URLs

urlpatterns = [
    path('v1/', include(router.urls)), # Includes all ViewSet routes under /v1/

    # Specific API function views (if any, not part of ViewSets)
    # Example: path('v1/some-custom-action/', api_views.SomeCustomActionView.as_view(), name='custom-action'),

    # Views for triggering tasks (could also be actions on ViewSets)
    path('v1/commodities/<uuid:commodity_id>/trigger-update/',
         api_views.TriggerCommodityUpdateView.as_view(),
         name='trigger-commodity-update'), # commodity_id matches the kwarg in the view
    path('v1/commodities/trigger-update-all/',
         api_views.TriggerAllCommoditiesUpdateView.as_view(),
         name='trigger-all-commodities-update'),

    # View for specific commodity price history (could also be an action on CommodityViewSet)
    path('v1/commodities/<uuid:commodity_id>/price-history/',
         api_views.CommodityPriceHistoryView.as_view(),
         name='commodity-price-history'),
]


# commodity_tracker/apps/market/web_urls.py
# This file is for Django-rendered Web Page URLs (non-API)
from django.urls import path
from .views import web_views # Ensure web_views is imported correctly

app_name = 'market-web' # Namespace for Web URLs

urlpatterns = [
    path('', web_views.CommodityListView.as_view(), name='commodity-list'), # Example: list at root
    path('commodities/<uuid:pk>/', web_views.CommodityDetailView.as_view(), name='commodity-detail'),
    path('commodities/data-sources/', web_views.DataSourceListView.as_view(), name='datasource-list'),
    path('commodities/data-sources/<int:pk>/', web_views.DataSourceDetailView.as_view(), name='datasource-detail'),
    path('update-logs/', web_views.MarketUpdateLogListView.as_view(), name='marketupdatelog-list'),
    path('update-logs/<uuid:pk>/', web_views.MarketUpdateLogDetailView.as_view(), name='marketupdatelog-detail'),
    # Add other web view URLs here
]


# commodity_tracker/apps/market/views/__init__.py
# This file can be empty or used to import key views for easier access from elsewhere.
# from . import api_views
# from . import web_views
# from . import base


# commodity_tracker/apps/market/views/base.py
"""
Base view classes for the market application.
"""
import logging
from django.views.generic import TemplateView
from django.shortcuts import get_object_or_404
from django.http import Http404
from rest_framework.views import APIView
from rest_framework import status as drf_status # Alias to avoid conflict with model status
from apps.core.mixins import CacheResponseMixin, JSONResponseMixin
from apps.core.exceptions import CommodityTrackerException
from apps.market.models import Commodity # For get_commodity_or_404

logger = logging.getLogger(__name__)


class BaseTemplateView(CacheResponseMixin, TemplateView):
    """
    Base template view with caching.
    Subclasses should define `template_name`.
    """
    cache_timeout = 300  # 5 minutes, can be overridden

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['page_title'] = getattr(self, 'page_title', self.model._meta.verbose_name_plural if hasattr(self, 'model') and self.model else "Page")
        return context


class BaseAPIView(JSONResponseMixin, APIView):
    """
    Base API view with standardized error handling and utility methods.
    Inherits JSONResponseMixin for success_response and error_response methods.
    """
    # permission_classes = [] # Define default permissions if needed

    def handle_exception(self, exc):
        """
        Handles exceptions raised in API views.
        Returns a standardized JSON error response.
        """
        if isinstance(exc, Http404): # Handle Django's Http404 specifically
            logger.warning(f"Resource not found (404): {exc}")
            return self.error_response(str(exc), status=drf_status.HTTP_404_NOT_FOUND)

        if isinstance(exc, CommodityTrackerException):
            logger.warning(f"CommodityTrackerException handled in API: {exc}")
            # Determine status code based on exception type if needed, default to 400
            custom_status = getattr(exc, 'status_code', drf_status.HTTP_400_BAD_REQUEST)
            return self.error_response(str(exc), status=custom_status)

        # For other unhandled exceptions, log them as errors and return a generic 500 response
        logger.error(f"Unhandled exception in API view: {exc}", exc_info=True)
        return self.error_response(
            "An unexpected server error occurred.",
            status=drf_status.HTTP_500_INTERNAL_SERVER_ERROR
        )

    def get_commodity_or_404(self, commodity_id_or_symbol, queryset=None):
        """
        Retrieves an active commodity by its UUID or symbol.
        Raises Http404 if not found.
        `queryset` can be provided to use a specific pre-filtered queryset.
        """
        if queryset is None:
            queryset = Commodity.active.all() # Default to active commodities

        try:
            # Check if it's a UUID
            from uuid import UUID
            uuid_obj = UUID(str(commodity_id_or_symbol), version=4)
            return get_object_or_404(queryset, id=uuid_obj)
        except (ValueError, TypeError):
            # Not a valid UUID, try symbol (case-insensitive)
            return get_object_or_404(queryset, symbol__iexact=str(commodity_id_or_symbol))
        except Commodity.DoesNotExist: # Should be caught by get_object_or_404
            raise Http404(f"Commodity with identifier '{commodity_id_or_symbol}' not found.")


# commodity_tracker/apps/market/views/api_views.py
import logging
from django.shortcuts import get_object_or_404
from django.utils import timezone
from datetime import timedelta
from rest_framework import viewsets, status as drf_status, generics
from rest_framework.response import Response
from rest_framework.decorators import action
from rest_framework.permissions import AllowAny # Or IsAuthenticated, etc.

from apps.market.models import Commodity, CommodityCategory, PriceData, DataSource, MarketUpdate
from apps.market.serializers import (
    CommoditySerializer, CommodityDetailSerializer, CommodityCategorySerializer,
    PriceDataSerializer, DataSourceSerializer, MarketUpdateLogSerializer
)
from apps.market.tasks import update_single_commodity_prices_task, update_all_active_commodities_prices_task
from .base import BaseAPIView # Use our custom BaseAPIView for error handling

logger = logging.getLogger(__name__)


class CommodityViewSet(viewsets.ReadOnlyModelViewSet):
    """
    API endpoint for viewing Commodities.
    Provides `list` and `retrieve` actions by default.
    """
    queryset = Commodity.active.all().select_related('category', 'data_source').order_by('name')
    serializer_class = CommoditySerializer
    permission_classes = [AllowAny] # Adjust as needed
    lookup_field = 'id' # Use UUID for lookup, can also add lookup by symbol if needed

    def get_serializer_class(self):
        if self.action == 'retrieve':
            return CommodityDetailSerializer
        return CommoditySerializer

    @action(detail=False, methods=['get'], url_path='by-symbol/(?P<symbol>[^/.]+)')
    def by_symbol(self, request, symbol=None):
        """Retrieve a commodity by its symbol."""
        commodity = get_object_or_404(Commodity.active, symbol__iexact=symbol)
        serializer = CommodityDetailSerializer(commodity, context={'request': request})
        return Response(serializer.data)

    @action(detail=True, methods=['post'], url_path='trigger-update')
    def trigger_update_action(self, request, id=None): # 'id' matches lookup_field
        """
        Triggers an asynchronous price update for this specific commodity.
        Accessible via /api/market/v1/commodities/{id}/trigger-update/
        """
        commodity = self.get_object() # Gets commodity by ID
        logger.info(f"API trigger_update action called for commodity: {commodity.symbol}")

        task_kwargs = request.data.get('fetch_kwargs', {}) # Allow passing fetch_kwargs via request body
        task = update_single_commodity_prices_task.delay(commodity_id=str(commodity.id), **task_kwargs)
        
        return Response(
            {'message': f'Price update task for {commodity.symbol} has been queued.', 'task_id': task.id},
            status=drf_status.HTTP_202_ACCEPTED
        )

    @action(detail=False, methods=['get'])
    def needs_update(self, request):
        """Returns commodities that might need a price update (e.g., no recent data)."""
        hours = int(request.query_params.get('hours', 24))
        commodities_to_update = Commodity.objects.get_commodities_for_update(hours=hours)
        page = self.paginate_queryset(commodities_to_update)
        if page is not None:
            serializer = self.get_serializer(page, many=True)
            return self.get_paginated_response(serializer.data)
        serializer = self.get_serializer(commodities_to_update, many=True)
        return Response(serializer.data)


class CommodityCategoryViewSet(viewsets.ReadOnlyModelViewSet):
    """API endpoint for viewing Commodity Categories."""
    queryset = CommodityCategory.objects.all().prefetch_related('commodities').order_by('name')
    serializer_class = CommodityCategorySerializer
    permission_classes = [AllowAny]


class DataSourceViewSet(viewsets.ReadOnlyModelViewSet):
    """API endpoint for viewing Data Sources."""
    queryset = DataSource.objects.all().order_by('name')
    serializer_class = DataSourceSerializer
    permission_classes = [AllowAny]


class PriceDataViewSet(viewsets.ReadOnlyModelViewSet):
    """API endpoint for viewing Price Data."""
    queryset = PriceData.objects.all().select_related('commodity').order_by('-timestamp')
    serializer_class = PriceDataSerializer
    permission_classes = [AllowAny]
    filterset_fields = ['commodity', 'commodity__symbol', 'timestamp'] # Enable filtering

    def get_queryset(self):
        qs = super().get_queryset()
        commodity_id = self.request.query_params.get('commodity_id')
        commodity_symbol = self.request.query_params.get('commodity_symbol')
        
        if commodity_id:
            qs = qs.filter(commodity_id=commodity_id)
        elif commodity_symbol:
            qs = qs.filter(commodity__symbol__iexact=commodity_symbol)
            
        # Date range filtering
        date_from_str = self.request.query_params.get('date_from')
        date_to_str = self.request.query_params.get('date_to')
        if date_from_str:
            date_from = timezone.datetime.strptime(date_from_str, '%Y-%m-%d').replace(tzinfo=timezone.utc)
            qs = qs.filter(timestamp__gte=date_from)
        if date_to_str:
            date_to = (timezone.datetime.strptime(date_to_str, '%Y-%m-%d') + timedelta(days=1)).replace(tzinfo=timezone.utc)
            qs = qs.filter(timestamp__lt=date_to)
            
        return qs


class MarketUpdateLogViewSet(viewsets.ReadOnlyModelViewSet):
    """API endpoint for viewing Market Update Logs."""
    queryset = MarketUpdate.objects.all().select_related('data_source', 'commodity').order_by('-started_at', '-created_at')
    serializer_class = MarketUpdateLogSerializer
    permission_classes = [AllowAny] # Adjust if logs are sensitive
    filterset_fields = ['status', 'data_source', 'commodity', 'commodity__symbol']


# Standalone API Views (not part of ViewSets, using BaseAPIView for error handling)

class TriggerCommodityUpdateView(BaseAPIView):
    """
    Standalone API view to trigger an asynchronous price update for a specific commodity.
    Example URL: /api/market/v1/commodities/{commodity_id}/trigger-update/
    """
    permission_classes = [AllowAny] # Or IsAdminUser, etc.

    def post(self, request, commodity_id, *args, **kwargs): # commodity_id from URL
        commodity = self.get_commodity_or_404(commodity_id) # Uses helper from BaseAPIView
        logger.info(f"API TriggerCommodityUpdateView POST called for commodity: {commodity.symbol}")

        task_kwargs = request.data.get('fetch_kwargs', {}) # Allow passing fetch_kwargs
        task = update_single_commodity_prices_task.delay(commodity_id=str(commodity.id), **task_kwargs)

        return self.success_response(
            data={'task_id': task.id},
            message=f'Price update task for {commodity.symbol} has been queued.',
            status=drf_status.HTTP_202_ACCEPTED
        )

class TriggerAllCommoditiesUpdateView(BaseAPIView):
    """
    Standalone API view to trigger an asynchronous price update for ALL active commodities.
    Example URL: /api/market/v1/commodities/trigger-update-all/
    """
    permission_classes = [AllowAny] # Or IsAdminUser, etc.

    def post(self, request, *args, **kwargs):
        logger.info("API TriggerAllCommoditiesUpdateView POST called.")

        task_kwargs = request.data.get('fetch_kwargs', {}) # Allow passing fetch_kwargs
        task = update_all_active_commodities_prices_task.delay(**task_kwargs)

        return self.success_response(
            data={'task_id': task.id},
            message='Task to update all active commodities has been queued.',
            status=drf_status.HTTP_202_ACCEPTED
        )

class CommodityPriceHistoryView(generics.ListAPIView): # Using DRF's ListAPIView for convenience
    """
    API view to get price history for a specific commodity.
    Example URL: /api/market/v1/commodities/{commodity_id}/price-history/?days=60
    """
    serializer_class = PriceDataSerializer
    permission_classes = [AllowAny]

    def get_queryset(self):
        commodity_id_or_symbol = self.kwargs.get('commodity_id') # From URL
        # Use the helper from BaseAPIView (though generics.ListAPIView doesn't inherit it directly)
        # For simplicity, re-implement or ensure it's available.
        try:
            from uuid import UUID
            commodity = get_object_or_404(Commodity.active, id=UUID(str(commodity_id_or_symbol)))
        except (ValueError, TypeError):
            commodity = get_object_or_404(Commodity.active, symbol__iexact=str(commodity_id_or_symbol))
        
        days_str = self.request.query_params.get('days', '30')
        try:
            days = int(days_str)
            if not (1 <= days <= 3650 * 2): # Limit days (e.g., up to 20 years)
                days = 30
        except ValueError:
            days = 30

        start_date = timezone.now() - timedelta(days=days)
        return PriceData.objects.filter(commodity=commodity, timestamp__gte=start_date).order_by('timestamp')

    def list(self, request, *args, **kwargs):
        queryset = self.get_queryset()
        commodity_id_or_symbol = self.kwargs.get('commodity_id')
        days_param = self.request.query_params.get('days', '30')

        if not queryset.exists():
            return Response(
                {'message': f'No price history found for commodity {commodity_id_or_symbol} in the last {days_param} days.'},
                status=drf_status.HTTP_404_NOT_FOUND
            )

        page = self.paginate_queryset(queryset)
        if page is not None:
            serializer = self.get_serializer(page, many=True)
            return self.get_paginated_response(serializer.data)

        serializer = self.get_serializer(queryset, many=True)
        return Response(serializer.data)


# commodity_tracker/apps/market/views/web_views.py
from django.views.generic import ListView, DetailView
from django.urls import reverse_lazy
# from django.shortcuts import render # Not used for these class-based views
from apps.market.models import Commodity, PriceData, DataSource, MarketUpdate # Import all relevant models
from .base import BaseTemplateView # Use our custom BaseTemplateView
from django.utils import timezone
from datetime import timedelta
from django.contrib.auth.mixins import LoginRequiredMixin # Example: if views need login

# Example: class AuthenticatedBaseTemplateView(LoginRequiredMixin, BaseTemplateView):
# login_url = reverse_lazy('login') # Define your login URL name

class CommodityListView(BaseTemplateView): # Or AuthenticatedBaseTemplateView
    model = Commodity
    template_name = 'market/web/commodity_list.html' # Path within app's templates dir
    context_object_name = 'commodities'
    paginate_by = 15
    page_title = "Commodities Overview"

    def get_queryset(self):
        return Commodity.active.all().select_related('category', 'data_source').order_by('name')


class CommodityDetailView(BaseTemplateView):
    model = Commodity
    template_name = 'market/web/commodity_detail.html'
    context_object_name = 'commodity'
    # pk_url_kwarg = 'pk' is default for DetailView using UUID

    def get_queryset(self):
        # Allow viewing any commodity by pk, active or not, for detail view
        return Commodity.objects.all().select_related('category', 'data_source')

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        commodity = self.object # self.get_object() also works, self.object is set by get_queryset
        context['page_title'] = f"{commodity.name} ({commodity.symbol})"

        days_history = int(self.request.GET.get('days', 30)) # Allow changing history via query param
        if not (1 <= days_history <= 365 * 5): days_history = 30 # Cap history

        price_history = PriceData.objects.filter(
            commodity=commodity,
            timestamp__gte=timezone.now() - timedelta(days=days_history)
        ).order_by('timestamp') # Oldest first for charting

        context['price_history'] = price_history
        context['price_history_days'] = days_history

        if price_history:
            context['chart_labels'] = [p.timestamp.strftime('%Y-%m-%d') for p in price_history]
            context['chart_data_close'] = [float(p.close_price) for p in price_history]
            # Example: Add high/low if needed for chart
            # context['chart_data_high'] = [float(p.high_price) if p.high_price else None for p in price_history]
            # context['chart_data_low'] = [float(p.low_price) if p.low_price else None for p in price_history]
        return context


class DataSourceListView(BaseTemplateView):
    model = DataSource
    template_name = 'market/web/datasource_list.html'
    context_object_name = 'datasources'
    paginate_by = 20
    page_title = "Data Sources"

    def get_queryset(self):
        return DataSource.objects.all().order_by('name')


class DataSourceDetailView(BaseTemplateView):
    model = DataSource
    template_name = 'market/web/datasource_detail.html'
    context_object_name = 'datasource'
    # pk_url_kwarg = 'pk' is default (uses integer PK for DataSource)

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        datasource = self.object
        context['page_title'] = f"Data Source: {datasource.name}"
        # Get commodities using this data source
        context['commodities_using_source'] = Commodity.objects.filter(data_source=datasource, is_active=True).order_by('name')[:20]
        context['update_logs'] = MarketUpdate.objects.filter(data_source=datasource).order_by('-started_at')[:20]
        return context


class MarketUpdateLogListView(BaseTemplateView):
    model = MarketUpdate
    template_name = 'market/web/marketupdatelog_list.html'
    context_object_name = 'update_logs'
    paginate_by = 25
    page_title = "Market Update Logs"

    def get_queryset(self):
        return MarketUpdate.objects.all().select_related('data_source', 'commodity').order_by('-started_at', '-created_at')


class MarketUpdateLogDetailView(BaseTemplateView):
    model = MarketUpdate
    template_name = 'market/web/marketupdatelog_detail.html'
    context_object_name = 'update_log'
    # pk_url_kwarg = 'pk' (for UUID PK of MarketUpdate)

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        update_log = self.object
        context['page_title'] = f"Update Log Details: {update_log.id_short()}"
        return context


# commodity_tracker/apps/market/templates/market/web/base_web.html
"""
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{% block page_title %}{{ page_title|default:"Commodity Tracker" }}{% endblock page_title %}</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        body { padding-top: 5rem; }
        .navbar { margin-bottom: 20px; }
        .footer { padding: 20px 0; text-align: center; margin-top: 40px; background-color: #f8f9fa; }
        .table th, .table td { vertical-align: middle; }
        .chart-container { max-width: 900px; margin: auto; }
    </style>
    {% block extra_head %}{% endblock extra_head %}
</head>
<body>
    <nav class="navbar navbar-expand-md navbar-dark bg-dark fixed-top">
        <div class="container-fluid">
            <a class="navbar-brand" href="{% url 'market-web:commodity-list' %}">Commodity Tracker</a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav me-auto mb-2 mb-lg-0">
                    <li class="nav-item">
                        <a class="nav-link {% if request.resolver_match.url_name == 'commodity-list' %}active{% endif %}" href="{% url 'market-web:commodity-list' %}">Commodities</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link {% if request.resolver_match.url_name == 'datasource-list' %}active{% endif %}" href="{% url 'market-web:datasource-list' %}">Data Sources</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link {% if request.resolver_match.url_name == 'marketupdatelog-list' %}active{% endif %}" href="{% url 'market-web:marketupdatelog-list' %}">Update Logs</a>
                    </li>
                </ul>
                <ul class="navbar-nav">
                    {% if user.is_authenticated %}
                        <li class="nav-item"><span class="navbar-text me-2">Welcome, {{ user.username }}</span></li>
                        <li class="nav-item"><a class="nav-link" href="{% url 'admin:index' %}">Admin</a></li>
                        {% else %}
                        <li class="nav-item"><a class="nav-link" href="{% url 'admin:index' %}">Admin Login</a></li>
                    {% endif %}
                </ul>
            </div>
        </div>
    </nav>

    <main class="container mt-4">
        {% block content %}
        <p>Welcome to the Commodity Tracker. Select an option from the navigation.</p>
        {% endblock content %}
    </main>

    <footer class="footer">
        <div class="container">
            <p>&copy; {% now "Y" %} Commodity Tracker App. All rights reserved.</p>
        </div>
    </footer>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    {% block extra_scripts %}{% endblock extra_scripts %}
</body>
</html>
"""

# commodity_tracker/apps/market/templates/market/web/commodity_list.html
"""
{% extends "market/web/base_web.html" %}

{% block content %}
<div class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2 mb-3 border-bottom">
    <h1 class="h2">{{ page_title }}</h1>
    <!-- {% if perms.market.add_commodity %}
    <div class="btn-toolbar mb-2 mb-md-0">
        <a href="{% url 'admin:market_commodity_add' %}" class="btn btn-sm btn-outline-success">
            Add New Commodity
        </a>
    </div>
    {% endif %} -->
</div>

{% if commodities %}
    <div class="table-responsive">
        <table class="table table-striped table-hover">
            <thead>
                <tr>
                    <th>Name</th>
                    <th>Symbol</th>
                    <th>Category</th>
                    <th>Exchange</th>
                    <th>Data Source</th>
                    <th>Latest Price (Close)</th>
                    <th>Last Price Update</th>
                </tr>
            </thead>
            <tbody>
                {% for commodity in commodities %}
                <tr>
                    <td><a href="{% url 'market-web:commodity-detail' pk=commodity.id %}">{{ commodity.name }}</a></td>
                    <td>{{ commodity.symbol }}</td>
                    <td>{{ commodity.category.name|default:"N/A" }}</td>
                    <td>{{ commodity.exchange|default:"N/A" }}</td>
                    <td>{{ commodity.data_source.name }}</td>
                    <td>
                        {% with latest_price=commodity.get_latest_price %}
                            {{ latest_price.close_price|default:"N/A" }} {{ commodity.currency }}
                        {% endwith %}
                    </td>
                    <td>
                        {% with latest_price=commodity.get_latest_price %}
                            {{ latest_price.timestamp|date:"Y-m-d H:i"|default:"N/A" }}
                        {% endwith %}
                    </td>
                </tr>
                {% endfor %}
            </tbody>
        </table>
    </div>

    {% if is_paginated %}
        <nav aria-label="Commodity navigation">
            <ul class="pagination justify-content-center">
                {% if page_obj.has_previous %}
                    <li class="page-item"><a class="page-link" href="?page=1">&laquo; First</a></li>
                    <li class="page-item"><a class="page-link" href="?page={{ page_obj.previous_page_number }}">Previous</a></li>
                {% else %}
                    <li class="page-item disabled"><span class="page-link">&laquo; First</span></li>
                    <li class="page-item disabled"><span class="page-link">Previous</span></li>
                {% endif %}

                <li class="page-item active" aria-current="page">
                    <span class="page-link">Page {{ page_obj.number }} of {{ page_obj.paginator.num_pages }}</span>
                </li>

                {% if page_obj.has_next %}
                    <li class="page-item"><a class="page-link" href="?page={{ page_obj.next_page_number }}">Next</a></li>
                    <li class="page-item"><a class="page-link" href="?page={{ page_obj.paginator.num_pages }}">Last &raquo;</a></li>
                {% else %}
                    <li class="page-item disabled"><span class="page-link">Next</span></li>
                    <li class="page-item disabled"><span class="page-link">Last &raquo;</span></li>
                {% endif %}
            </ul>
        </nav>
    {% endif %}
{% else %}
    <div class="alert alert-info" role="alert">
        No active commodities found. You can add them via the <a href="{% url 'admin:market_commodity_add' %}" class="alert-link">admin panel</a>.
    </div>
{% endif %}
{% endblock content %}
"""

# commodity_tracker/apps/market/templates/market/web/commodity_detail.html
"""
{% extends "market/web/base_web.html" %}

{% block extra_head %}
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.7.0/dist/chart.min.js"></script>
{% endblock extra_head %}

{% block content %}
<div class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2 mb-3 border-bottom">
    <h1 class="h2">{{ page_title }}</h1>
    <div class="btn-toolbar mb-2 mb-md-0">
        <a href="{% url 'market-web:commodity-list' %}" class="btn btn-sm btn-outline-secondary me-2">
            &laquo; Back to List
        </a>
        <!-- {% if perms.market.change_commodity %}
        <a href="{% url 'admin:market_commodity_change' commodity.id %}" class="btn btn-sm btn-outline-primary">
            Edit in Admin
        </a>
        {% endif %} -->
    </div>
</div>

<div class="row">
    <div class="col-md-4">
        <div class="card mb-3">
            <div class="card-header"><strong>Commodity Details</strong></div>
            <ul class="list-group list-group-flush">
                <li class="list-group-item"><strong>Symbol:</strong> {{ commodity.symbol }}</li>
                <li class="list-group-item"><strong>Category:</strong> {{ commodity.category.name|default:"N/A" }}</li>
                <li class="list-group-item"><strong>Exchange:</strong> {{ commodity.exchange|default:"N/A" }}</li>
                <li class="list-group-item"><strong>Unit:</strong> {{ commodity.unit|default:"N/A" }}</li>
                <li class="list-group-item"><strong>Currency:</strong> {{ commodity.currency }}</li>
                <li class="list-group-item"><strong>Data Source:</strong> <a href="{% url 'market-web:datasource-detail' pk=commodity.data_source.id %}">{{ commodity.data_source.name }}</a></li>
                <li class="list-group-item"><strong>External ID:</strong> {{ commodity.external_id }}</li>
                <li class="list-group-item"><strong>Status:</strong> {% if commodity.is_active %}<span class="badge bg-success">Active</span>{% else %}<span class="badge bg-secondary">Inactive</span>{% endif %}</li>
                <li class="list-group-item"><strong>Meta Data:</strong> <pre>{{ commodity.meta_data|default:"{}" }}</pre></li>
            </ul>
        </div>
    </div>
    <div class="col-md-8">
        <div class="card mb-3">
            <div class="card-header"><strong>Latest Price Data</strong></div>
            {% with latest_price=commodity.get_latest_price %}
                {% if latest_price %}
                <ul class="list-group list-group-flush">
                    <li class="list-group-item"><strong>Timestamp:</strong> {{ latest_price.timestamp|date:"Y-m-d H:i:s T" }}</li>
                    <li class="list-group-item"><strong>Open:</strong> {{ latest_price.open_price|default:"N/A" }}</li>
                    <li class="list-group-item"><strong>High:</strong> {{ latest_price.high_price|default:"N/A" }}</li>
                    <li class="list-group-item"><strong>Low:</strong> {{ latest_price.low_price|default:"N/A" }}</li>
                    <li class="list-group-item"><strong>Close:</strong> {{ latest_price.close_price|default:"N/A" }}</li>
                    <li class="list-group-item"><strong>Volume:</strong> {{ latest_price.volume|default:"N/A" }}</li>
                    <li class="list-group-item"><strong>Change:</strong> {{ latest_price.price_change|floatformat:4|default:"N/A" }}</li>
                    <li class="list-group-item"><strong>% Change:</strong> {{ latest_price.price_change_percentage|floatformat:2|default:"N/A" }}%</li>
                </ul>
                {% else %}
                    <div class="card-body">
                        <p class="text-muted">No price data available yet for this commodity.</p>
                    </div>
                {% endif %}
            {% endwith %}
        </div>
    </div>
</div>

<div class="row mt-3">
    <div class="col-12">
        <div class="card">
            <div class="card-header">
                <strong>Price History (Last {{ price_history_days }} Days - Close Price)</strong>
                <form method="get" class="float-end d-inline-flex align-items-center">
                    <label for="days" class="form-label me-2">Days:</label>
                    <input type="number" name="days" id="days" value="{{ price_history_days }}" class="form-control form-control-sm" style="width: 80px;" min="1" max="1825">
                    <button type="submit" class="btn btn-sm btn-primary ms-2">Update</button>
                </form>
            </div>
            <div class="card-body chart-container">
                {% if price_history and chart_labels and chart_data_close %}
                    <canvas id="priceHistoryChart"></canvas>
                {% else %}
                    <p class="text-muted">No recent price history available to display chart.</p>
                {% endif %}
            </div>
        </div>
    </div>
</div>
{% endblock content %}

{% block extra_scripts %}
{% if price_history and chart_labels and chart_data_close %}
<script>
    document.addEventListener('DOMContentLoaded', function () {
        const ctx = document.getElementById('priceHistoryChart').getContext('2d');
        const priceHistoryChart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: {{ chart_labels|safe }},
                datasets: [{
                    label: 'Close Price ({{ commodity.currency }})',
                    data: {{ chart_data_close|safe }},
                    borderColor: 'rgb(75, 192, 192)',
                    backgroundColor: 'rgba(75, 192, 192, 0.2)',
                    tension: 0.1,
                    fill: true // Fill area under line
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false, // Allow chart to shrink if container is small
                scales: {
                    x: {
                        title: { display: true, text: 'Date' },
                        ticks: { autoSkip: true, maxTicksLimit: 15 } // Improve label readability
                    },
                    y: {
                        title: { display: true, text: 'Price ({{ commodity.currency }})' },
                        beginAtZero: false // Don't always start y-axis at zero
                    }
                },
                plugins: {
                    tooltip: { mode: 'index', intersect: false },
                    legend: { display: true, position: 'top' }
                }
            }
        });
    });
</script>
{% endif %}
{% endblock extra_scripts %}
"""

# commodity_tracker/apps/market/templates/market/web/datasource_list.html
"""
{% extends "market/web/base_web.html" %}

{% block content %}
<div class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2 mb-3 border-bottom">
    <h1 class="h2">{{ page_title }}</h1>
</div>

{% if datasources %}
    <div class="table-responsive">
        <table class="table table-striped table-hover">
            <thead>
                <tr>
                    <th>Name</th>
                    <th>Base URL</th>
                    <th>API Key Required</th>
                    <th>Rate Limit (per min)</th>
                    <th>Status</th>
                </tr>
            </thead>
            <tbody>
                {% for ds in datasources %}
                <tr>
                    <td><a href="{% url 'market-web:datasource-detail' pk=ds.id %}">{{ ds.name }}</a></td>
                    <td>{{ ds.base_url }}</td>
                    <td>{% if ds.api_key_required %}Yes{% else %}No{% endif %}</td>
                    <td>{{ ds.rate_limit_per_minute|default:"N/A" }}</td>
                    <td>{% if ds.is_active %}<span class="badge bg-success">Active</span>{% else %}<span class="badge bg-secondary">Inactive</span>{% endif %}</td>
                </tr>
                {% endfor %}
            </tbody>
        </table>
    </div>
    {% include "market/web/includes/pagination.html" %} {# Assuming pagination include exists #}
{% else %}
    <p class="alert alert-info">No data sources found.</p>
{% endif %}
{% endblock content %}
"""

# commodity_tracker/apps/market/templates/market/web/datasource_detail.html
"""
{% extends "market/web/base_web.html" %}

{% block content %}
<div class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2 mb-3 border-bottom">
    <h1 class="h2">{{ page_title }}</h1>
    <a href="{% url 'market-web:datasource-list' %}" class="btn btn-sm btn-outline-secondary">&laquo; Back to Data Sources</a>
</div>

<div class="card mb-3">
    <div class="card-header"><strong>Data Source Details</strong></div>
    <ul class="list-group list-group-flush">
        <li class="list-group-item"><strong>Name:</strong> {{ datasource.name }}</li>
        <li class="list-group-item"><strong>Base URL:</strong> {{ datasource.base_url }}</li>
        <li class="list-group-item"><strong>API Key Required:</strong> {% if datasource.api_key_required %}Yes{% else %}No{% endif %}</li>
        <li class="list-group-item"><strong>Rate Limit (per min):</strong> {{ datasource.rate_limit_per_minute|default:"N/A" }}</li>
        <li class="list-group-item"><strong>Status:</strong> {% if datasource.is_active %}<span class="badge bg-success">Active</span>{% else %}<span class="badge bg-secondary">Inactive</span>{% endif %}</li>
        <li class="list-group-item"><strong>Created:</strong> {{ datasource.created_at|date:"Y-m-d H:i" }}</li>
        <li class="list-group-item"><strong>Updated:</strong> {{ datasource.updated_at|date:"Y-m-d H:i" }}</li>
    </ul>
</div>

<h3 class="mt-4">Active Commodities Using This Source (Max 20)</h3>
{% if commodities_using_source %}
    <ul class="list-group">
        {% for commodity in commodities_using_source %}
            <li class="list-group-item">
                <a href="{% url 'market-web:commodity-detail' pk=commodity.id %}">{{ commodity.name }} ({{ commodity.symbol }})</a>
            </li>
        {% endfor %}
    </ul>
{% else %}
    <p class="text-muted">No active commodities are currently using this data source.</p>
{% endif %}

<h3 class="mt-4">Recent Update Logs (Max 20)</h3>
{% if update_logs %}
    <div class="table-responsive">
        <table class="table table-sm table-hover">
            <thead>
                <tr>
                    <th>Log ID</th>
                    <th>Commodity</th>
                    <th>Status</th>
                    <th>Started At</th>
                    <th>Duration</th>
                    <th>Records Created</th>
                </tr>
            </thead>
            <tbody>
                {% for log in update_logs %}
                <tr>
                    <td><a href="{% url 'market-web:marketupdatelog-detail' pk=log.id %}">{{ log.id_short }}</a></td>
                    <td>{{ log.commodity.symbol|default:"N/A" }}</td>
                    <td>
                        {% if log.status == 'SUCCESS' %}<span class="badge bg-success">{{ log.get_status_display }}</span>
                        {% elif log.status == 'FAILED' %}<span class="badge bg-danger">{{ log.get_status_display }}</span>
                        {% elif log.status == 'PARTIAL' %}<span class="badge bg-warning text-dark">{{ log.get_status_display }}</span>
                        {% elif log.status == 'RUNNING' %}<span class="badge bg-info text-dark">{{ log.get_status_display }}</span>
                        {% else %}<span class="badge bg-secondary">{{ log.get_status_display }}</span>
                        {% endif %}
                    </td>
                    <td>{{ log.started_at|date:"Y-m-d H:i"|default:"N/A" }}</td>
                    <td>{{ log.duration|default:"N/A" }}</td>
                    <td>{{ log.records_created }}</td>
                </tr>
                {% endfor %}
            </tbody>
        </table>
    </div>
{% else %}
    <p class="text-muted">No recent update logs for this data source.</p>
{% endif %}

{% endblock content %}
"""

# commodity_tracker/apps/market/templates/market/web/marketupdatelog_list.html
"""
{% extends "market/web/base_web.html" %}

{% block content %}
<div class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2 mb-3 border-bottom">
    <h1 class="h2">{{ page_title }}</h1>
</div>

{% if update_logs %}
    <div class="table-responsive">
        <table class="table table-striped table-hover table-sm">
            <thead>
                <tr>
                    <th>Log ID</th>
                    <th>Data Source</th>
                    <th>Commodity</th>
                    <th>Status</th>
                    <th>Task ID</th>
                    <th>Started At</th>
                    <th>Duration</th>
                    <th>Fetched</th>
                    <th>Created</th>
                </tr>
            </thead>
            <tbody>
                {% for log in update_logs %}
                <tr>
                    <td><a href="{% url 'market-web:marketupdatelog-detail' pk=log.id %}">{{ log.id_short }}</a></td>
                    <td>{{ log.data_source.name }}</td>
                    <td>{{ log.commodity.symbol|default:"N/A (Source Level)" }}</td>
                    <td>
                        {% if log.status == 'SUCCESS' %}<span class="badge bg-success">{{ log.get_status_display }}</span>
                        {% elif log.status == 'FAILED' %}<span class="badge bg-danger">{{ log.get_status_display }}</span>
                        {% elif log.status == 'PARTIAL' %}<span class="badge bg-warning text-dark">{{ log.get_status_display }}</span>
                        {% elif log.status == 'RUNNING' %}<span class="badge bg-info text-dark">{{ log.get_status_display }}</span>
                        {% else %}<span class="badge bg-secondary">{{ log.get_status_display }}</span>
                        {% endif %}
                    </td>
                    <td>{{ log.task_id|default:"N/A"|truncatechars:15 }}</td>
                    <td>{{ log.started_at|date:"Y-m-d H:i"|default:"N/A" }}</td>
                    <td>{{ log.duration|default:"N/A" }}</td>
                    <td>{{ log.records_fetched }}</td>
                    <td>{{ log.records_created }}</td>
                </tr>
                {% endfor %}
            </tbody>
        </table>
    </div>
    {% include "market/web/includes/pagination.html" %}
{% else %}
    <p class="alert alert-info">No market update logs found.</p>
{% endif %}
{% endblock content %}
"""

# commodity_tracker/apps/market/templates/market/web/marketupdatelog_detail.html
"""
{% extends "market/web/base_web.html" %}

{% block content %}
<div class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2 mb-3 border-bottom">
    <h1 class="h2">{{ page_title }}</h1>
    <a href="{% url 'market-web:marketupdatelog-list' %}" class="btn btn-sm btn-outline-secondary">&laquo; Back to Logs</a>
</div>

<div class="card">
    <div class="card-header"><strong>Log Details for ID: {{ update_log.id }}</strong></div>
    <ul class="list-group list-group-flush">
        <li class="list-group-item"><strong>Data Source:</strong> {{ update_log.data_source.name }}</li>
        <li class="list-group-item"><strong>Commodity:</strong> {{ update_log.commodity.name|default:"N/A (Source Level)" }} ({{ update_log.commodity.symbol|default:"-" }})</li>
        <li class="list-group-item"><strong>Status:</strong>
            {% if update_log.status == 'SUCCESS' %}<span class="badge bg-success">{{ update_log.get_status_display }}</span>
            {% elif update_log.status == 'FAILED' %}<span class="badge bg-danger">{{ update_log.get_status_display }}</span>
            {% elif update_log.status == 'PARTIAL' %}<span class="badge bg-warning text-dark">{{ update_log.get_status_display }}</span>
            {% elif update_log.status == 'RUNNING' %}<span class="badge bg-info text-dark">{{ update_log.get_status_display }}</span>
            {% else %}<span class="badge bg-secondary">{{ update_log.get_status_display }}</span>
            {% endif %}
        </li>
        <li class="list-group-item"><strong>Celery Task ID:</strong> {{ update_log.task_id|default:"N/A" }}</li>
        <li class="list-group-item"><strong>Started At:</strong> {{ update_log.started_at|date:"Y-m-d H:i:s T"|default:"N/A" }}</li>
        <li class="list-group-item"><strong>Completed At:</strong> {{ update_log.completed_at|date:"Y-m-d H:i:s T"|default:"N/A" }}</li>
        <li class="list-group-item"><strong>Duration:</strong> {{ update_log.duration|default:"N/A" }}</li>
        <li class="list-group-item"><strong>Records Fetched:</strong> {{ update_log.records_fetched }}</li>
        <li class="list-group-item"><strong>Records Created (New PriceData):</strong> {{ update_log.records_created }}</li>
        <li class="list-group-item"><strong>Records Updated (PriceData):</strong> {{ update_log.records_updated }}</li>
        <li class="list-group-item"><strong>Log Created At:</strong> {{ update_log.created_at|date:"Y-m-d H:i:s T" }}</li>
    </ul>
    {% if update_log.error_message %}
    <div class="card-footer">
        <strong>Error Message:</strong>
        <pre class="bg-light p-2 rounded mt-1" style="max-height: 200px; overflow-y: auto;">{{ update_log.error_message }}</pre>
    </div>
    {% endif %}
</div>
{% endblock content %}
"""

# commodity_tracker/apps/market/templates/market/web/includes/pagination.html
# (Create this file if it doesn't exist)
"""
{% if is_paginated %}
    <nav aria-label="Page navigation">
        <ul class="pagination justify-content-center mt-4">
            {% if page_obj.has_previous %}
                <li class="page-item">
                    <a class="page-link" href="?page=1" aria-label="First">
                        <span aria-hidden="true">&laquo;&laquo;</span> First
                    </a>
                </li>
                <li class="page-item">
                    <a class="page-link" href="?page={{ page_obj.previous_page_number }}" aria-label="Previous">
                        <span aria-hidden="true">&laquo;</span> Previous
                    </a>
                </li>
            {% else %}
                <li class="page-item disabled">
                    <span class="page-link" aria-hidden="true">&laquo;&laquo; First</span>
                </li>
                <li class="page-item disabled">
                    <span class="page-link" aria-hidden="true">&laquo; Previous</span>
                </li>
            {% endif %}

            {% for num in page_obj.paginator.page_range %}
                {% if page_obj.number == num %}
                    <li class="page-item active" aria-current="page"><span class="page-link">{{ num }}</span></li>
                {% elif num > page_obj.number|add:'-3' and num < page_obj.number|add:'3' %}
                    <li class="page-item"><a class="page-link" href="?page={{ num }}">{{ num }}</a></li>
                {% elif num == page_obj.number|add:'-3' or num == page_obj.number|add:'3' %}
                    <li class="page-item disabled"><span class="page-link">...</span></li>
                {% endif %}
            {% endfor %}

            {% if page_obj.has_next %}
                <li class="page-item">
                    <a class="page-link" href="?page={{ page_obj.next_page_number }}" aria-label="Next">
                        Next <span aria-hidden="true">&raquo;</span>
                    </a>
                </li>
                <li class="page-item">
                    <a class="page-link" href="?page={{ page_obj.paginator.num_pages }}" aria-label="Last">
                        Last <span aria-hidden="true">&raquo;&raquo;</span>
                    </a>
                </li>
            {% else %}
                <li class="page-item disabled">
                    <span class="page-link" aria-hidden="true">Next &raquo;</span>
                </li>
                <li class="page-item disabled">
                    <span class="page-link" aria-hidden="true">Last &raquo;&raquo;</span>
                </li>
            {% endif %}
        </ul>
    </nav>
{% endif %}
"""


# commodity_tracker/Dockerfile
# Example Dockerfile (adjust as needed for your production setup)
"""
# Use an official Python runtime as a parent image
FROM python:3.11-slim-buster

# Set environment variables to prevent Python from writing .pyc files and to buffer output
ENV PYTHONDONTWRITEBYTECODE 1
ENV PYTHONUNBUFFERED 1

# Set work directory in the container
WORKDIR /app

# Install system dependencies
# - build-essential: for compiling some Python packages if needed from source
# - libpq-dev: for psycopg2 (PostgreSQL adapter)
# - gettext: for Django's internationalization features if used
RUN apt-get update \
    && apt-get install -y --no-install-recommends \
        build-essential \
        libpq-dev \
        gettext \
    # Add any other system dependencies your project needs
    && apt-get clean \
    && rm -rf /var/lib/apt/lists/*

# Upgrade pip
RUN pip install --upgrade pip

# Copy requirements.txt first to leverage Docker cache
COPY requirements.txt /app/
# Install Python dependencies
RUN pip install --no-cache-dir -r requirements.txt

# Copy the entire project into the container
COPY . /app/

# Expose the port the app runs on (same as Gunicorn/Uvicorn will run on)
EXPOSE 8000

# Command to run the application using Gunicorn (for production)
# Ensure 'gunicorn' is in your requirements.txt
# Adjust --workers based on your server's CPU cores (typically 2-4 per core)
# The DJANGO_SETTINGS_MODULE might need to be set if you have separate production settings
# ENV DJANGO_SETTINGS_MODULE=commodity_tracker.settings.production
# CMD ["gunicorn", "commodity_tracker.wsgi:application", "--bind", "0.0.0.0:8000", "--workers", "3"]

# For development, you might run manage.py runserver, but this is not for production.
# A separate docker-compose.override.yml is better for development command.
# If this Dockerfile is ONLY for production, the Gunicorn CMD is appropriate.
# If it's also for dev, you might have a more generic entrypoint script.
"""


# commodity_tracker/docker-compose.yml
# Example docker-compose.yml for development and production structure
"""
version: '3.8'

services:
  db: # PostgreSQL Database Service
    image: postgres:15-alpine
    container_name: commodity_tracker_db
    volumes:
      - postgres_data:/var/lib/postgresql/data/ # Persist database data
    environment:
      # These should match your .env file and Django's DATABASE_URL settings
      - POSTGRES_USER=${POSTGRES_USER:-devuser}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD:-devpassword}
      - POSTGRES_DB=${POSTGRES_DB:-commodity_tracker_dev}
    ports:
      - "5432:5432" # Expose PostgreSQL port to host (optional, for direct access)
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U $$POSTGRES_USER -d $$POSTGRES_DB"]
      interval: 10s
      timeout: 5s
      retries: 5
    restart: unless-stopped

  redis: # Redis Service (for Celery broker/backend and caching)
    image: redis:7-alpine
    container_name: commodity_tracker_redis
    ports:
      - "6379:6379" # Expose Redis port to host (optional)
    # volumes:
    #   - redis_data:/data # Optional: for Redis data persistence
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5
    restart: unless-stopped

  web: # Django Web Application Service
    build:
      context: .
      dockerfile: Dockerfile # Specify your Dockerfile
    container_name: commodity_tracker_web
    # Command for development (overridden in docker-compose.override.yml usually)
    # For production, this would be your Gunicorn command:
    # command: gunicorn commodity_tracker.wsgi:application --bind 0.0.0.0:8000 --workers 3
    command: python manage.py runserver 0.0.0.0:8000
    volumes:
      - .:/app # Mount current directory to /app in container for live code changes (dev)
    ports:
      - "8000:8000" # Map port 8000 on host to 8000 in container
    env_file:
      - .env # Load environment variables from .env file
    depends_on:
      db:
        condition: service_healthy # Wait for db to be healthy
      redis:
        condition: service_healthy # Wait for redis to be healthy
    restart: unless-stopped

  celery_worker: # Celery Worker Service
    build:
      context: .
      dockerfile: Dockerfile
    container_name: commodity_tracker_celery_worker
    # Command to start Celery worker. Adjust queue and concurrency as needed.
    command: celery -A commodity_tracker worker -l INFO -Q default -c 2
    volumes:
      - .:/app # Mount for code changes (dev)
    env_file:
      - .env
    depends_on:
      redis:
        condition: service_healthy
      db: # If tasks interact with the database
        condition: service_healthy
    restart: unless-stopped

  celery_beat: # Celery Beat Scheduler Service (for periodic tasks)
    build:
      context: .
      dockerfile: Dockerfile
    container_name: commodity_tracker_celery_beat
    # Command to start Celery beat. Uses DatabaseScheduler.
    command: celery -A commodity_tracker beat -l INFO --scheduler django_celery_beat.schedulers:DatabaseScheduler
    volumes:
      - .:/app
    env_file:
      - .env
    depends_on:
      redis:
        condition: service_healthy
      db: # django_celery_beat stores schedules in the database
        condition: service_healthy
    restart: unless-stopped

volumes: # Define named volumes for data persistence
  postgres_data:
  # redis_data: # Uncomment if you added volume for redis persistence

# Notes for .env file regarding Docker Compose:
# DATABASE_URL=postgres://${POSTGRES_USER:-devuser}:${POSTGRES_PASSWORD:-devpassword}@db:5432/${POSTGRES_DB:-commodity_tracker_dev}
# (Note 'db' as hostname, which is the service name for PostgreSQL in this docker-compose file)
# REDIS_URL=redis://redis:6379/0
# CELERY_BROKER_URL=redis://redis:6379/0
# CELERY_RESULT_BACKEND=redis://redis:6379/0
"""

# commodity_tracker/requirements.txt
"""
Django==5.0.1
djangorestframework==3.14.0
celery==5.3.6 # Updated to a more recent stable version
redis==5.0.1
requests==2.31.0
python-decouple==3.8
psycopg2-binary==2.9.9 # For PostgreSQL
django-cors-headers==4.3.1
django-extensions==3.2.3
dj-database-url==2.1.0 # For parsing DATABASE_URL from .env
django-redis==5.4.0 # For Redis cache backend
gunicorn==22.0.0 # For production WSGI server (if using Docker for prod)
django-celery-beat==2.6.0 # For scheduling periodic tasks with Celery
# Pillow==10.2.0 # Example: if you add ImageFields later
# django-filter==24.2 # For advanced filtering in DRF if needed
"""

# commodity_tracker/manage.py
# (This is the standard Django manage.py, no changes needed from what `django-admin startproject` creates)
"""#!/usr/bin/env python
import os
import sys

if __name__ == "__main__":
    # Adjust this if your settings are structured differently, e.g., for production/development split
    os.environ.setdefault("DJANGO_SETTINGS_MODULE", "commodity_tracker.settings.base")
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)
"""

# commodity_tracker/commodity_tracker/wsgi.py
# (Standard Django wsgi.py)
"""
import os

from django.core.wsgi import get_wsgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'commodity_tracker.settings.base')

application = get_wsgi_application()
"""

# commodity_tracker/commodity_tracker/asgi.py
# (Standard Django asgi.py, useful if you plan to use Channels or async features)
"""
import os

from django.core.asgi import get_asgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'commodity_tracker.settings.base')

application = get_asgi_application()
"""

# commodity_tracker/templates/.gitkeep
# (Empty file to ensure the global 'templates' directory is created if you use it)

# commodity_tracker/static/.gitkeep
# (Empty file to ensure the global 'static' directory is created if you use it)

# commodity_tracker/apps/.gitkeep
# (Empty file to ensure the 'apps' directory is created)

# commodity_tracker/apps/core/templates/.gitkeep
# (Empty file if core app has templates)

# commodity_tracker/apps/market/templates/.gitkeep
# (Empty file if market app has templates, though specific ones are in market/web)

# commodity_tracker/apps/market/templates/market/.gitkeep
# (Empty file for the 'market' subdir in templates)

# commodity_tracker/apps/market/templates/market/web/.gitkeep
# (Empty file for the 'web' subdir)

# commodity_tracker/apps/market/templates/market/web/includes/.gitkeep
# (Empty file for template includes)

```
I've updated the `FRED_API_KEY` in the `.env.example` section with the key you provided. The rest of the codebase remains the same as the comprehensive version we established.

Remember to rename `.env.example` to `.env` and fill in all your other actual credentials and API keys when you set up the project local